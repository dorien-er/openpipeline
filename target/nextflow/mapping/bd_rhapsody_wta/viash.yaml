functionality:
  name: "bd_rhapsody_wta"
  namespace: "mapping"
  version: "0.1.0"
  authors:
  - name: "Robrecht Cannoodt"
    email: "rcannood@gmail.com"
    roles:
    - "maintainer"
    props:
      github: "rcannood"
      orcid: "0000-0003-3641-729X"
  arguments:
  - type: "file"
    name: "--input"
    alternatives:
    - "-i"
    description: "Path to your read files in the FASTQ.GZ format. You may specify\
      \ as many R1/R2 read pairs as you want."
    must_exist: false
    required: true
    direction: "Input"
    multiple: true
    multiple_sep: ":"
  - type: "double"
    name: "--subsample"
    alternatives: []
    description: "A number >1 or fraction (0 < n < 1) to indicate the number or percentage\
      \ of reads to subsample."
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "file"
    name: "--reference_genome"
    alternatives:
    - "-r"
    description: "Path to STAR index for tar.gz format."
    must_exist: false
    required: true
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "file"
    name: "--transcriptome_annotation"
    alternatives:
    - "-t"
    description: "Path to GTF annotation file"
    must_exist: false
    required: true
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "file"
    name: "--output"
    alternatives:
    - "-o"
    description: "Output folder. Output still needs to be processed further."
    must_exist: false
    required: true
    direction: "Output"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--exact_cell_count"
    alternatives: []
    description: "Exact cell count - Set a specific number (>=1) of cells as putative,\
      \ based on those with the highest error-corrected read count"
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "boolean"
    name: "--disable_putative_calling"
    alternatives: []
    description: "Disable Refined Putative Cell Calling - Determine putative cells\
      \ using only the basic algorithm (minimum second derivative along the cumulative\
      \ reads curve). The refined algorithm attempts to remove false positives and\
      \ recover false negatives, but may not be ideal for certain complex mixtures\
      \ of cell types. Does not apply if Exact Cell Count is set."
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  resources:
  - type: "bash_script"
    text: |
      #!/usr/bin/env bash
      
      ###############################
      #    bd_rhapsody_wta 0.1.0    #
      ###############################
      
      # This wrapper script is auto-generated by viash 0.5.0-rc2 and is thus a
      # derivative work thereof. This software comes with ABSOLUTELY NO WARRANTY from
      # Data Intuitive.  The component may contain files which fall under a different
      # license. The authors of this component should specify the license in the
      # header of such files, or include a separate license file detailing the
      # licenses of all included files.
      #
      # Component authors:
      # * Robrecht Cannoodt <rcannood@gmail.com> (maintainer) {github: rcannood, orcid: 0000-0003-3641-729X}
      
      set -e
      
      if [ -z "$VIASH_TEMP" ]; then
        VIASH_TEMP=/tmp
      fi
      
      # define helper functions
      # ViashQuote: put quotes around non flag values
      # $1     : unquoted string
      # return : possibly quoted string
      # examples:
      #   ViashQuote --foo      # returns --foo
      #   ViashQuote bar        # returns 'bar'
      #   Viashquote --foo=bar  # returns --foo='bar'
      function ViashQuote {
        if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
          echo "$1" | sed "s#=\(.*\)#='\1'#"
        elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
          echo "$1"
        else
          echo "'$1'"
        fi
      }
      # ViashRemoveFlags: Remove leading flag
      # $1     : string with a possible leading flag
      # return : string without possible leading flag
      # examples:
      #   ViashRemoveFlags --foo=bar  # returns bar
      function ViashRemoveFlags {
        echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
      }
      # ViashSourceDir: return the path of a bash file, following symlinks
      # usage   : ViashSourceDir ${BASH_SOURCE[0]}
      # $1      : Should always be set to ${BASH_SOURCE[0]}
      # returns : The absolute path of the bash file
      function ViashSourceDir {
        SOURCE="$1"
        while [ -h "$SOURCE" ]; do
          DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
          SOURCE="$(readlink "$SOURCE")"
          [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
        done
        cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
      }
      VIASH_VERBOSITY=5
      
      # see https://en.wikipedia.org/wiki/Syslog#Severity_level
      
      # ViashLog: Log events depending on the verbosity level
      # usage: ViashLog 1 alert Oh no something went wrong!
      # $1: required verbosity level
      # $2: display tag
      # $3+: messages to display
      # stdout: Your input, prepended by '[$2] '. 
      function ViashLog {
        local required_level="$1"
        local display_tag="$2"
        shift 2
        if [ $VIASH_VERBOSITY -ge $required_level ]; then
          echo "[$display_tag]" "$@"
        fi
      }
      
      # ViashEmergency: log events when the system is unstable
      # usage: ViashEmergency Oh no something went wrong.
      # stdout: Your input, prepended by '[emergency] '. 
      function ViashEmergency {
        ViashLog 0 emergency $@
      }
      
      # ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
      # usage: ViashAlert Oh no something went wrong.
      # stdout: Your input, prepended by '[alert] '. 
      function ViashAlert {
        ViashLog 1 alert $@
      }
      
      # ViashCritical: log events when a critical condition occurs
      # usage: ViashCritical Oh no something went wrong.
      # stdout: Your input, prepended by '[critical] '. 
      function ViashCritical {
        ViashLog 2 critical $@
      }
      
      # ViashError: log events when an error condition occurs
      # usage: ViashError Oh no something went wrong.
      # stdout: Your input, prepended by '[error] '. 
      function ViashError {
        ViashLog 3 error $@
      }
      
      # ViashWarning: log potentially abnormal events
      # usage: ViashWarning Something may have gone wrong.
      # stdout: Your input, prepended by '[warning] '. 
      function ViashWarning {
        ViashLog 4 warning $@
      }
      
      # ViashNotice: log significant but normal events
      # usage: ViashNotice This just happened.
      # stdout: Your input, prepended by '[notice] '. 
      function ViashNotice {
        ViashLog 5 notice $@
      }
      
      # ViashInfo: log normal events
      # usage: ViashInfo This just happened.
      # stdout: Your input, prepended by '[info] '. 
      function ViashInfo {
        ViashLog 6 info $@
      }
      
      # ViashDebug: log all events, for debugging purposes
      # usage: ViashDebug This just happened.
      # stdout: Your input, prepended by '[debug] '. 
      function ViashDebug {
        ViashLog 7 debug $@
      }
      
      # find source folder of this component
      VIASH_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`
      
      
      # ViashHelp: Display helpful explanation about this executable
      function ViashHelp {
         echo "bd_rhapsody_wta 0.1.0"
      echo "A viash component for the BD Rhapsody Analysis CWL pipeline.
      
      The CWL pipeline file is obtained by cloning 'https://bitbucket.org/CRSwDev/cwl/src/master/' and removing all objects with class 'DockerRequirement' from the JSON.
      
      The reference_genome and transcriptome_annotation files can be downloaded from these locations:
        - Human: http://bd-rhapsody-public.s3-website-us-east-1.amazonaws.com/Rhapsody-WTA/GRCh38-PhiX-gencodev29/
        - Mouse: http://bd-rhapsody-public.s3-website-us-east-1.amazonaws.com/Rhapsody-WTA/GRCm38-PhiX-gencodevM19/"
         echo
         echo "Options:"
      
      echo "    -i, --input"
      echo "        type: file, required parameter, multiple values allowed"
      echo "        Path to your read files in the FASTQ.GZ format. You may specify as many R1/R2 read pairs as you want."
      echo ""
      
      
      echo "    --subsample"
      echo "        type: double"
      echo "        A number >1 or fraction (0 < n < 1) to indicate the number or percentage of reads to subsample."
      echo ""
      
      
      echo "    -r, --reference_genome"
      echo "        type: file, required parameter"
      echo "        Path to STAR index for tar.gz format."
      echo ""
      
      
      echo "    -t, --transcriptome_annotation"
      echo "        type: file, required parameter"
      echo "        Path to GTF annotation file"
      echo ""
      
      
      echo "    -o, --output"
      echo "        type: file, required parameter, output"
      echo "        Output folder. Output still needs to be processed further."
      echo ""
      
      
      echo "    --exact_cell_count"
      echo "        type: integer"
      echo "        Exact cell count - Set a specific number (>=1) of cells as putative, based on those with the highest error-corrected read count"
      echo ""
      
      
      echo "    --disable_putative_calling"
      echo "        type: boolean"
      echo "        Disable Refined Putative Cell Calling - Determine putative cells using only the basic algorithm (minimum second derivative along the cumulative reads curve). The refined algorithm attempts to remove false positives and recover false negatives, but may not be ideal for certain complex mixtures of cell types. Does not apply if Exact Cell Count is set."
      echo ""
      
      }
      
      # initialise array
      VIASH_POSITIONAL_ARGS=''
      
      while [[ $# -gt 0 ]]; do
          case "$1" in
              -h|--help)
                  ViashHelp
                  exit
                  ;;
              -v|--verbose)
                  let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
                  shift 1
                  ;;
              -vv)
                  let "VIASH_VERBOSITY=VIASH_VERBOSITY+2"
                  shift 1
                  ;;
              --verbosity)
                  VIASH_VERBOSITY="$2"
                  shift 2
                  ;;
              --verbosity=*)
                  VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
                  shift 1
                  ;;
              --version)
                  echo "bd_rhapsody_wta 0.1.0"
                  exit
                  ;;
              --input)
                  if [ -z "$VIASH_PAR_INPUT" ]; then
                    VIASH_PAR_INPUT="$2"
                  else
                    VIASH_PAR_INPUT="$VIASH_PAR_INPUT:""$2"
                  fi
                  shift 2
                  ;;
              --input=*)
                  if [ -z "$VIASH_PAR_INPUT" ]; then
                    VIASH_PAR_INPUT=$(ViashRemoveFlags "$1")
                  else
                    VIASH_PAR_INPUT="$VIASH_PAR_INPUT:"$(ViashRemoveFlags "$1")
                  fi
                  shift 1
                  ;;
              -i)
                  if [ -z "$VIASH_PAR_INPUT" ]; then
                    VIASH_PAR_INPUT="$2"
                  else
                    VIASH_PAR_INPUT="$VIASH_PAR_INPUT:""$2"
                  fi
                  shift 2
                  ;;
              --subsample)
                  VIASH_PAR_SUBSAMPLE="$2"
                  shift 2
                  ;;
              --subsample=*)
                  VIASH_PAR_SUBSAMPLE=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --reference_genome)
                  VIASH_PAR_REFERENCE_GENOME="$2"
                  shift 2
                  ;;
              --reference_genome=*)
                  VIASH_PAR_REFERENCE_GENOME=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              -r)
                  VIASH_PAR_REFERENCE_GENOME="$2"
                  shift 2
                  ;;
              --transcriptome_annotation)
                  VIASH_PAR_TRANSCRIPTOME_ANNOTATION="$2"
                  shift 2
                  ;;
              --transcriptome_annotation=*)
                  VIASH_PAR_TRANSCRIPTOME_ANNOTATION=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              -t)
                  VIASH_PAR_TRANSCRIPTOME_ANNOTATION="$2"
                  shift 2
                  ;;
              --output)
                  VIASH_PAR_OUTPUT="$2"
                  shift 2
                  ;;
              --output=*)
                  VIASH_PAR_OUTPUT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              -o)
                  VIASH_PAR_OUTPUT="$2"
                  shift 2
                  ;;
              --exact_cell_count)
                  VIASH_PAR_EXACT_CELL_COUNT="$2"
                  shift 2
                  ;;
              --exact_cell_count=*)
                  VIASH_PAR_EXACT_CELL_COUNT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --disable_putative_calling)
                  VIASH_PAR_DISABLE_PUTATIVE_CALLING="$2"
                  shift 2
                  ;;
              --disable_putative_calling=*)
                  VIASH_PAR_DISABLE_PUTATIVE_CALLING=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              *)  # positional arg or unknown option
                  # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
                  VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
                  shift # past argument
                  ;;
          esac
      done
      
      # parse positional parameters
      eval set -- $VIASH_POSITIONAL_ARGS
      
      
      
      # check whether required parameters exist
      if [ -z "$VIASH_PAR_INPUT" ]; then
        ViashError '--input' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_REFERENCE_GENOME" ]; then
        ViashError '--reference_genome' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ]; then
        ViashError '--transcriptome_annotation' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_OUTPUT" ]; then
        ViashError '--output' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      
      
      
      cat << VIASHEOF | bash
      set -e
      tempscript=\$(mktemp "$VIASH_TEMP/viash-run-bd_rhapsody_wta-XXXXXX")
      function clean_up {
        rm "\$tempscript"
      }
      trap clean_up EXIT
      cat > "\$tempscript" << 'VIASHMAIN'
      # The following code has been auto-generated by Viash.
      par_input='$VIASH_PAR_INPUT'
      par_subsample='$VIASH_PAR_SUBSAMPLE'
      par_reference_genome='$VIASH_PAR_REFERENCE_GENOME'
      par_transcriptome_annotation='$VIASH_PAR_TRANSCRIPTOME_ANNOTATION'
      par_output='$VIASH_PAR_OUTPUT'
      par_exact_cell_count='$VIASH_PAR_EXACT_CELL_COUNT'
      par_disable_putative_calling='$VIASH_PAR_DISABLE_PUTATIVE_CALLING'
      
      resources_dir="$VIASH_RESOURCES_DIR"
      
      #!/bin/bash
      
      # yq eval 'del(.. | select(has("dockerPull")))' cwl/v1.9.1/rhapsody_wta_1.9.1.cwl -j > rhapsody_wta_1.9.1_nodocker.cwl
      # doesn't work
      
      mkdir -p \$par_output
      
      cat > \$par_output/config.yml << HERE
      #!/usr/bin/env cwl-runner
      
      cwl:tool: rhapsody
      
      # This is a template YML file used to specify the inputs for a BD Genomics WTA Rhapsody Analysis pipeline run. See the
      # BD Genomics Analysis Setup User Guide (Doc ID: 47383) for more details. Enter the following information:
      
      ## Reference_Genome (required) - Path to STAR index for tar.gz format. See Doc ID: 47383 for instructions to obtain pre-built STAR index file.
      Reference_Genome:
         class: File
         location: "\$(realpath \$par_reference_genome)"
      
      ## Transcriptome_Annotation (required) - Path to GTF annotation file
      Transcriptome_Annotation:
         class: File
         location: "\$(realpath \$par_transcriptome_annotation)"
      
      ## Reads (required) - Path to your read files in the FASTQ.GZ format. You may specify as many R1/R2 read pairs as you want.
      Reads:
      HERE
      
      # process fastq files
      IFS=:
      set -f
      for val in \$par_input; do
        unset IFS
        cat >> \$par_output/config.yml << HERE
       - class: File
         location: "\$(realpath \$val)"
      HERE
      done
      set +f
      
      # Add abseq reference, if specified
      if [ ! -z "\$par_abseq_reference" ]; then
        cat >> \$par_output/config.yml << HERE
      
      ## AbSeq_Reference (optional) - Path to the AbSeq reference file in FASTA format.  Only needed if BD AbSeq Ab-Oligos are used.
      AbSeq_Reference:
      HERE
      
        # process abseq reference files
        IFS=:
        set -f
        for val in \$par_abseq_reference; do
          unset IFS
      
          cat >> \$par_output/config.yml << HERE
       - class: File
         location: "\$(realpath \$val)"
      HERE
        done
        set +f
      fi
      
      # Add supplemental reference, if specified
      if [ ! -z "\$par_supplemental_reference" ]; then
        cat >> \$par_output/config.yml << HERE
      
      # Supplemental_Reference (optional) - Path to the supplemental reference file in FASTA format.  Only needed if there are additional transgene sequences used in the experiment.
      Supplemental_Reference:
      HERE
      
        # process supplemental reference files
        IFS=:
        set -f
        for val in \$par_supplemental_reference; do
          unset IFS
      
          cat >> \$par_output/config.yml << HERE
       - class: File
         location: "\$(realpath \$val)"
      HERE
        done
        set +f
      fi
      
      # Add exact cell count, if specified
      if [ ! -z "\$par_exact_cell_count" ]; then
        cat >> \$par_output/config.yml << HERE
      
      ## Exact cell count - Set a specific number (>=1) of cells as putative, based on those with the highest error-corrected read count
      Exact_Cell_Count: \$par_exact_cell_count
      HERE
      fi
      
      # Add Disable Refined Putative Cell Calling, if specified
      if [ ! -z "\$par_disable_putative_calling" ]; then
        cat >> \$par_output/config.yml << HERE
      
      ## Disable Refined Putative Cell Calling - Determine putative cells using only the basic algorithm (minimum second derivative along the cumulative reads curve).
      ## The refined algorithm attempts to remove false positives and recover false negatives, but may not be ideal for certain complex mixtures of cell types.
      ## Does not apply if Exact Cell Count is set. Values can be true or false.
      Basic_Algo_Only: \$par_disable_putative_calling
      HERE
      fi
      
      # add subsample, if specified
      if [ ! -z "\$par_subsample" ]; then
        cat >> \$par_output/config.yml << HERE
      
      ## Subsample (optional) - A number >1 or fraction (0 < n < 1) to indicate the number or percentage of reads to subsample.
      Subsample: \$par_subsample
      HERE
      fi
      
      cd \$par_output
      
      cwl-runner \$resources_dir/rhapsody_wta_1.9.1_nodocker.cwl config.yml
      VIASHMAIN
      PATH="$VIASH_RESOURCES_DIR:\$PATH"
      
      bash "\$tempscript"
      
      VIASHEOF
      

    dest: "bd_rhapsody_wta"
    is_executable: true
  - type: "file"
    path: "rhapsody_wta_1.9.1_nodocker.cwl"
  - type: "file"
    text: |
        docker.enabled = true
        docker.runOptions = "-i -v ${baseDir}:${baseDir}"
        process.container = "dataintuitive/viash"
        params {
          bd_rhapsody_wta__input = "${params.input}"
          bd_rhapsody_wta__subsample = "no_default_value_configured"
          bd_rhapsody_wta__reference_genome = "${params.reference_genome}"
          bd_rhapsody_wta__transcriptome_annotation = "${params.transcriptome_annotation}"
          bd_rhapsody_wta__output = "${params.output}"
          bd_rhapsody_wta__exact_cell_count = "no_default_value_configured"
          bd_rhapsody_wta__disable_putative_calling = "no_default_value_configured"
          id = ""
          input = ""
          output = ""
          testScript = ""
          testResources = [  ]
          bd_rhapsody_wta {
            name = "bd_rhapsody_wta"
            container = "mapping_bd_rhapsody_wta"
            containerTag = "0.1.0"
            containerRegistry = "openpipeline"
            command = "bd_rhapsody_wta"
            tests {
              isDefined = false
              testScript = "NA"
              testResources = [  ]
            }
            arguments {
              input {
                name = "input"
                otype = "--"
                required = true
                type = "file"
                direction = "Input"
                multiple = true
                multiple_sep = ":"
                value = "${params.bd_rhapsody_wta__input}"
                description = "Path to your read files in the FASTQ.GZ format. You may specify as many R1/R2 read pairs as you want."
              }
              subsample {
                name = "subsample"
                otype = "--"
                required = false
                type = "double"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.bd_rhapsody_wta__subsample}"
                description = "A number >1 or fraction (0 < n < 1) to indicate the number or percentage of reads to subsample."
              }
              reference_genome {
                name = "reference_genome"
                otype = "--"
                required = true
                type = "file"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.bd_rhapsody_wta__reference_genome}"
                description = "Path to STAR index for tar.gz format."
              }
              transcriptome_annotation {
                name = "transcriptome_annotation"
                otype = "--"
                required = true
                type = "file"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.bd_rhapsody_wta__transcriptome_annotation}"
                description = "Path to GTF annotation file"
              }
              output {
                name = "output"
                otype = "--"
                required = true
                type = "file"
                direction = "Output"
                multiple = false
                multiple_sep = ":"
                value = "${params.bd_rhapsody_wta__output}"
                description = "Output folder. Output still needs to be processed further."
              }
              exact_cell_count {
                name = "exact_cell_count"
                otype = "--"
                required = false
                type = "integer"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.bd_rhapsody_wta__exact_cell_count}"
                description = "Exact cell count - Set a specific number (>=1) of cells as putative, based on those with the highest error-corrected read count"
              }
              disable_putative_calling {
                name = "disable_putative_calling"
                otype = "--"
                required = false
                type = "boolean"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.bd_rhapsody_wta__disable_putative_calling}"
                description = "Disable Refined Putative Cell Calling - Determine putative cells using only the basic algorithm (minimum second derivative along the cumulative reads curve). The refined algorithm attempts to remove false positives and recover false negatives, but may not be ideal for certain complex mixtures of cell types. Does not apply if Exact Cell Count is set."
              }
            }
          }
        }

    dest: "nextflow.config"
  - type: "file"
    text: |
      nextflow.enable.dsl=2
      
      params.test = false
      params.debug = false
      
      def renderCLI(command, arguments) {
      
        def argumentsList = arguments.collect{ it ->
          (it.otype == "")
            ? "\'" + it.value + "\'"
            : (it.type == "boolean_true")
              ? it.otype + it.name
              : (it.value == "no_default_value_configured")
                ? ""
                : it.otype + it.name + " \'" + ((it.value in List && it.multiple) ? it.value.join(it.multiple_sep): it.value) + "\'"
        }
      
        def command_line = command + argumentsList
      
        return command_line.join(" ")
      }
      
      def effectiveContainer(processParams) {
        def _registry = params.containsKey("containerRegistry") ? params.containerRegistry : processParams.containerRegistry
        def _name = processParams.container
        def _tag = params.containsKey("containerTag") ? params.containerTag : processParams.containerTag
      
        return (_registry == "" ? "" : _registry + "/") + _name + ":" + _tag
      }
      
      // Convert the nextflow.config arguments list to a List instead of a LinkedHashMap
      // The rest of this main.nf script uses the Map form
      def argumentsAsList(_params) {
        def overrideArgs = _params.arguments.collect{ key, value -> value }
        def newParams = _params + [ "arguments" : overrideArgs ]
        return newParams
      }
      
      
      // Use the params map, create a hashmap of the filenames for output
      // output filename is <sample>.<method>.<arg_name>[.extension]
      def outFromIn(_params) {
      
        def id = _params.id
      
        _params
          .arguments
          .findAll{ it -> it.type == "file" && it.direction == "Output" }
          .collect{ it ->
            // If a default (dflt) attribute is present, strip the extension from the filename,
            // otherwise just use the option name as an extension.
            def extOrName = (it.dflt != null) ? it.dflt.split(/\./).last() : it.name
            // The output filename is <sample> . <modulename> . <extension>
            def newName =
              (id != "")
                ? id + "." + "bd_rhapsody_wta" + "." + extOrName
                : "bd_rhapsody_wta" + "." + extOrName
            it + [ value : newName ]
          }
      
      }
      
      // A process that filters out output from the output Map
      process filterOutput {
      
        input:
          tuple val(id), val(input), val(_params)
        output:
          tuple val(id), val(output), val(_params)
        when:
          input.keySet().contains("output")
        exec:
          output = input["output"]
      
      }
      
      def overrideIO(_params, inputs, outputs) {
      
        // `inputs` in fact can be one of:
        // - `String`,
        // - `List[String]`,
        // - `Map[String, String | List[String]]`
        // Please refer to the docs for more info
        def overrideArgs = _params.arguments.collect{ it ->
          if (it.type == "file") {
            if (it.direction == "Input") {
              (inputs in List || inputs in HashMap)
                ? (inputs in List)
                  ? it + [ "value" : inputs.join(it.multiple_sep)]
                  : (inputs[it.name] != null)
                    ? (inputs[it.name] in List)
                      ? it + [ "value" : inputs[it.name].join(it.multiple_sep)]
                      : it + [ "value" : inputs[it.name]]
                    : it
                : it + [ "value" : inputs ]
            } else {
              (outputs in List || outputs in HashMap)
                ? (outputs in List)
                  ? it + [ "value" : outputs.join(it.multiple_sep)]
                  : (outputs[it.name] != null)
                    ? (outputs[it.name] in List)
                      ? it + [ "value" : outputs[it.name].join(it.multiple_sep)]
                      : it + [ "value" : outputs[it.name]]
                    : it
                : it + [ "value" : outputs ]
            }
          } else {
            it
          }
        }
      
        def newParams = _params + [ "arguments" : overrideArgs ]
      
        return newParams
      
      }
      
      process bd_rhapsody_wta_process {
      
      
        tag "${id}"
        echo { (params.debug == true) ? true : false }
        cache 'deep'
        stageInMode "symlink"
        container "${container}"
      
        input:
          tuple val(id), path(input), val(output), val(container), val(cli), val(_params)
        output:
          tuple val("${id}"), path(output), val(_params)
        script:
          if (params.test)
            """
            # Some useful stuff
            export NUMBA_CACHE_DIR=/tmp/numba-cache
            # Running the pre-hook when necessary
            # Adding NXF's `$moduleDir` to the path in order to resolve our own wrappers
            export PATH="./:${moduleDir}:\$PATH"
            ./${params.bd_rhapsody_wta.tests.testScript} | tee $output
            """
          else
            """
            # Some useful stuff
            export NUMBA_CACHE_DIR=/tmp/numba-cache
            # Running the pre-hook when necessary
            # Adding NXF's `$moduleDir` to the path in order to resolve our own wrappers
            export PATH="${moduleDir}:\$PATH"
            $cli
            """
      }
      
      workflow bd_rhapsody_wta {
      
        take:
        id_input_params_
      
        main:
      
        def key = "bd_rhapsody_wta"
      
        def id_input_output_function_cli_params_ =
          id_input_params_.map{ id, input, _params ->
      
            // Start from the (global) params and overwrite with the (local) _params
            def defaultParams = params[key] ? params[key] : [:]
            def overrideParams = _params[key] ? _params[key] : [:]
            def updtParams = defaultParams + overrideParams
            // Convert to List[Map] for the arguments
            def newParams = argumentsAsList(updtParams) + [ "id" : id ]
      
            // Generate output filenames, out comes a Map
            def output = outFromIn(newParams)
      
            // The process expects Path or List[Path], Maps need to be converted
            def inputsForProcess =
              (input in HashMap)
                ? input.collect{ k, v -> v }.flatten()
                : input
            def outputsForProcess = output.collect{ it.value }
      
            // For our machinery, we convert Path -> String in the input
            def inputs =
              (input in List || input in HashMap)
                ? (input in List)
                  ? input.collect{ it.name }
                  : input.collectEntries{ k, v -> [ k, (v in List) ? v.collect{it.name} : v.name ] }
                : input.name
            outputs = output.collectEntries{ [(it.name): it.value] }
      
            def finalParams = overrideIO(newParams, inputs, outputs)
      
            new Tuple6(
              id,
              inputsForProcess,
              outputsForProcess,
              effectiveContainer(finalParams),
              renderCLI([finalParams.command], finalParams.arguments),
              finalParams
              )
          }
      
        result_ = bd_rhapsody_wta_process(id_input_output_function_cli_params_) \
          | join(id_input_params_) \
          | map{ id, output, _params, input, original_params ->
              def parsedOutput = _params.arguments
                .findAll{ it.type == "file" && it.direction == "Output" }
                .withIndex()
                .collectEntries{ it, i ->
                  // with one entry, output is of type Path and array selections
                  // would select just one element from the path
                  [(it.name): (output in List) ? output[i] : output ]
                }
              new Tuple3(id, parsedOutput, original_params)
            }
      
        result_ \
          | filter { it[1].keySet().size() > 1 } \
          | view{
              ">> Be careful, multiple outputs from this component!"
          }
      
        emit:
        result_.flatMap{ it ->
          (it[1].keySet().size() > 1)
            ? it[1].collect{ k, el -> [ it[0], [ (k): el ], it[2] ] }
            : it[1].collect{ k, el -> [ it[0], el, it[2] ] }
        }
      }
      
      workflow {
      
        def id = params.id
        def _params = argumentsAsList(params.bd_rhapsody_wta) + [ "id" : id ]
        def p = _params
          .arguments
          .findAll{ it.type == "file" && it.direction == "Input" }
          .collectEntries{ [(it.name): file(params[it.name]) ] }
      
        def ch_ = Channel.from("").map{ s -> new Tuple3(id, p, params)}
      
        result = bd_rhapsody_wta(ch_)
        result.view{ it[1] }
      }
      
      // This workflow is not production-ready yet, we leave it in for future dev
      // TODO
      workflow test {
      
        take:
        rootDir
      
        main:
        params.test = true
        params.bd_rhapsody_wta.output = "bd_rhapsody_wta.log"
      
        Channel.from(rootDir) \
          | filter { params.bd_rhapsody_wta.tests.isDefined } \
          | map{ p -> new Tuple3(
              "tests",
              params.bd_rhapsody_wta.tests.testResources.collect{ file( p + it ) },
              params
          )} \
          | bd_rhapsody_wta
      
        emit:
        bd_rhapsody_wta.out
      }

    dest: "main.nf"
  description: "A viash component for the BD Rhapsody Analysis CWL pipeline.\n\nThe\
    \ CWL pipeline file is obtained by cloning 'https://bitbucket.org/CRSwDev/cwl/src/master/'\
    \ and removing all objects with class 'DockerRequirement' from the JSON.\n\nThe\
    \ reference_genome and transcriptome_annotation files can be downloaded from these\
    \ locations:\n  - Human: http://bd-rhapsody-public.s3-website-us-east-1.amazonaws.com/Rhapsody-WTA/GRCh38-PhiX-gencodev29/\n\
    \  - Mouse: http://bd-rhapsody-public.s3-website-us-east-1.amazonaws.com/Rhapsody-WTA/GRCm38-PhiX-gencodevM19/\n"
  tests: []
  info: {}
platform:
  type: "nextflow"
  id: "nextflow"
  registry: "openpipeline"
  namespace_separator: "_"
  labels: []
platforms: []
info:
  config: "src/mapping/bd_rhapsody_wta/config.vsh.yaml"
  platform: "nextflow"
  output: "target/nextflow/mapping/bd_rhapsody_wta"
  executable: "target/nextflow/mapping/bd_rhapsody_wta/bd_rhapsody_wta"
  viash_version: "0.5.0-rc2"
  git_commit: "badb7db2c58b2085f612b279822aaadf0a7b2dc4"
  git_remote: "https://github.com/openpipeline-bio/openpipeline"
