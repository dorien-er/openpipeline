functionality:
  name: "umap"
  namespace: "projection"
  version: "main_build"
  authors:
  - name: "Dries De Maeyer"
    email: "ddemaeyer@gmail.com"
    roles:
    - "maintainer"
    props:
      account: "ddemaey1"
  arguments:
  - type: "file"
    name: "--input"
    alternatives: []
    description: "Input h5ad file"
    must_exist: false
    required: true
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "file"
    name: "--output"
    alternatives:
    - "-o"
    description: "Output h5ad file."
    must_exist: false
    required: true
    direction: "Output"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--min_dist"
    alternatives: []
    description: "The effective minimum distance between embedded points. Smaller\
      \ values will result in a more clustered/clumped embedding where nearby points\
      \ on the manifold are drawn closer together, while larger values will result\
      \ on a more even dispersal of points. The value should be set relative to the\
      \ spread value, which determines the scale at which embedded points will be\
      \ spread out. The default of in the umap-learn package is 0.1."
    default: 0.5
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--alpha"
    alternatives: []
    description: "The initial learning rate for the embedding optimization."
    default: 1.0
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--gamma"
    alternatives: []
    description: "Weighting applied to negative samples in low dimensional embedding\
      \ optimization. Values higher than one will result in greater weight being given\
      \ to negative samples."
    default: 1.0
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--random_seed"
    alternatives: []
    description: "Random seed for Leiden algrithm."
    default: 0
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--negative_sample_rate"
    alternatives: []
    description: "The number of negative edge/1-simplex samples to use per positive\
      \ edge/1-simplex sample in optimizing the low dimensional embedding."
    default: 5
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "string"
    name: "--init_pos"
    alternatives: []
    description: "How to initialize the low dimensional embedding. Called init in\
      \ the original UMAP. Options are paga, spectral and random."
    default: "spectral"
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  resources:
  - type: "bash_script"
    text: |
      #!/usr/bin/env bash
      
      #########################
      #    umap main_build    #
      #########################
      
      # This wrapper script is auto-generated by viash 0.5.0 and is thus a derivative
      # work thereof. This software comes with ABSOLUTELY NO WARRANTY from Data
      # Intuitive.  The component may contain files which fall under a different
      # license. The authors of this component should specify the license in the
      # header of such files, or include a separate license file detailing the
      # licenses of all included files.
      #
      # Component authors:
      # * Dries De Maeyer <ddemaeyer@gmail.com> (maintainer) {account: ddemaey1}
      
      set -e
      
      if [ -z "$VIASH_TEMP" ]; then
        VIASH_TEMP=/tmp
      fi
      
      # define helper functions
      # ViashQuote: put quotes around non flag values
      # $1     : unquoted string
      # return : possibly quoted string
      # examples:
      #   ViashQuote --foo      # returns --foo
      #   ViashQuote bar        # returns 'bar'
      #   Viashquote --foo=bar  # returns --foo='bar'
      function ViashQuote {
        if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
          echo "$1" | sed "s#=\(.*\)#='\1'#"
        elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
          echo "$1"
        else
          echo "'$1'"
        fi
      }
      # ViashRemoveFlags: Remove leading flag
      # $1     : string with a possible leading flag
      # return : string without possible leading flag
      # examples:
      #   ViashRemoveFlags --foo=bar  # returns bar
      function ViashRemoveFlags {
        echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
      }
      # ViashSourceDir: return the path of a bash file, following symlinks
      # usage   : ViashSourceDir ${BASH_SOURCE[0]}
      # $1      : Should always be set to ${BASH_SOURCE[0]}
      # returns : The absolute path of the bash file
      function ViashSourceDir {
        SOURCE="$1"
        while [ -h "$SOURCE" ]; do
          DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
          SOURCE="$(readlink "$SOURCE")"
          [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
        done
        cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
      }
      VIASH_VERBOSITY=5
      
      # see https://en.wikipedia.org/wiki/Syslog#Severity_level
      
      # ViashLog: Log events depending on the verbosity level
      # usage: ViashLog 1 alert Oh no something went wrong!
      # $1: required verbosity level
      # $2: display tag
      # $3+: messages to display
      # stdout: Your input, prepended by '[$2] '. 
      function ViashLog {
        local required_level="$1"
        local display_tag="$2"
        shift 2
        if [ $VIASH_VERBOSITY -ge $required_level ]; then
          echo "[$display_tag]" "$@"
        fi
      }
      
      # ViashEmergency: log events when the system is unstable
      # usage: ViashEmergency Oh no something went wrong.
      # stdout: Your input, prepended by '[emergency] '. 
      function ViashEmergency {
        ViashLog 0 emergency $@
      }
      
      # ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
      # usage: ViashAlert Oh no something went wrong.
      # stdout: Your input, prepended by '[alert] '. 
      function ViashAlert {
        ViashLog 1 alert $@
      }
      
      # ViashCritical: log events when a critical condition occurs
      # usage: ViashCritical Oh no something went wrong.
      # stdout: Your input, prepended by '[critical] '. 
      function ViashCritical {
        ViashLog 2 critical $@
      }
      
      # ViashError: log events when an error condition occurs
      # usage: ViashError Oh no something went wrong.
      # stdout: Your input, prepended by '[error] '. 
      function ViashError {
        ViashLog 3 error $@
      }
      
      # ViashWarning: log potentially abnormal events
      # usage: ViashWarning Something may have gone wrong.
      # stdout: Your input, prepended by '[warning] '. 
      function ViashWarning {
        ViashLog 4 warning $@
      }
      
      # ViashNotice: log significant but normal events
      # usage: ViashNotice This just happened.
      # stdout: Your input, prepended by '[notice] '. 
      function ViashNotice {
        ViashLog 5 notice $@
      }
      
      # ViashInfo: log normal events
      # usage: ViashInfo This just happened.
      # stdout: Your input, prepended by '[info] '. 
      function ViashInfo {
        ViashLog 6 info $@
      }
      
      # ViashDebug: log all events, for debugging purposes
      # usage: ViashDebug This just happened.
      # stdout: Your input, prepended by '[debug] '. 
      function ViashDebug {
        ViashLog 7 debug $@
      }
      
      # find source folder of this component
      VIASH_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`
      
      
      # ViashHelp: Display helpful explanation about this executable
      function ViashHelp {
        echo "umap main_build"
        echo "UMAP(Uniform Manifold Approximation and Projection) is a novel manifold learning technique for dimension reduction. UMAP is constructed from a theoretical framework based in Riemannian geometry and algebraic topology. The result is a practical scalable algorithm that applies to real world data. The UMAP algorithm is competitive with t-SNE for visualization quality, and arguably preserves more of the global structure with superior run time performance. Furthermore, UMAP has no computational restrictions on embedding dimension, making it viable as a general purpose dimension reduction technique for machine learning. "
        echo ""
        echo "For more information about the method see https://arxiv.org/abs/1802.03426"
        echo
        echo "Options:"
      
        echo "   --input"
        echo "        type: file, required parameter"
        echo "        Input h5ad file"
        echo ""
      
      
        echo "   -o, --output"
        echo "        type: file, required parameter, output"
        echo "        Output h5ad file."
        echo ""
      
      
        echo "   --min_dist"
        echo "        type: double"
        echo "        default: 0.5"
        echo "        The effective minimum distance between embedded points. Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points. The value should be set relative to the spread value, which determines the scale at which embedded points will be spread out. The default of in the umap-learn package is 0.1."
        echo ""
      
      
        echo "   --alpha"
        echo "        type: double"
        echo "        default: 1.0"
        echo "        The initial learning rate for the embedding optimization."
        echo ""
      
      
        echo "   --gamma"
        echo "        type: double"
        echo "        default: 1.0"
        echo "        Weighting applied to negative samples in low dimensional embedding optimization. Values higher than one will result in greater weight being given to negative samples."
        echo ""
      
      
        echo "   --random_seed"
        echo "        type: integer"
        echo "        default: 0"
        echo "        Random seed for Leiden algrithm."
        echo ""
      
      
        echo "   --negative_sample_rate"
        echo "        type: integer"
        echo "        default: 5"
        echo "        The number of negative edge/1-simplex samples to use per positive edge/1-simplex sample in optimizing the low dimensional embedding."
        echo ""
      
      
        echo "   --init_pos"
        echo "        type: string"
        echo "        default: spectral"
        echo "        How to initialize the low dimensional embedding. Called init in the original UMAP. Options are paga, spectral and random."
        echo ""
      
      }
      
      # initialise array
      VIASH_POSITIONAL_ARGS=''
      
      while [[ $# -gt 0 ]]; do
          case "$1" in
              -h|--help)
                  ViashHelp
                  exit
                  ;;
              -v|--verbose)
                  let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
                  shift 1
                  ;;
              -vv)
                  let "VIASH_VERBOSITY=VIASH_VERBOSITY+2"
                  shift 1
                  ;;
              --verbosity)
                  VIASH_VERBOSITY="$2"
                  shift 2
                  ;;
              --verbosity=*)
                  VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
                  shift 1
                  ;;
              --version)
                  echo "umap main_build"
                  exit
                  ;;
              --input)
                  VIASH_PAR_INPUT="$2"
                  shift 2
                  ;;
              --input=*)
                  VIASH_PAR_INPUT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --output)
                  VIASH_PAR_OUTPUT="$2"
                  shift 2
                  ;;
              --output=*)
                  VIASH_PAR_OUTPUT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              -o)
                  VIASH_PAR_OUTPUT="$2"
                  shift 2
                  ;;
              --min_dist)
                  VIASH_PAR_MIN_DIST="$2"
                  shift 2
                  ;;
              --min_dist=*)
                  VIASH_PAR_MIN_DIST=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --alpha)
                  VIASH_PAR_ALPHA="$2"
                  shift 2
                  ;;
              --alpha=*)
                  VIASH_PAR_ALPHA=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --gamma)
                  VIASH_PAR_GAMMA="$2"
                  shift 2
                  ;;
              --gamma=*)
                  VIASH_PAR_GAMMA=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --random_seed)
                  VIASH_PAR_RANDOM_SEED="$2"
                  shift 2
                  ;;
              --random_seed=*)
                  VIASH_PAR_RANDOM_SEED=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --negative_sample_rate)
                  VIASH_PAR_NEGATIVE_SAMPLE_RATE="$2"
                  shift 2
                  ;;
              --negative_sample_rate=*)
                  VIASH_PAR_NEGATIVE_SAMPLE_RATE=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --init_pos)
                  VIASH_PAR_INIT_POS="$2"
                  shift 2
                  ;;
              --init_pos=*)
                  VIASH_PAR_INIT_POS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              *)  # positional arg or unknown option
                  # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
                  VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
                  shift # past argument
                  ;;
          esac
      done
      
      # parse positional parameters
      eval set -- $VIASH_POSITIONAL_ARGS
      
      
      
      # check whether required parameters exist
      if [ -z "$VIASH_PAR_INPUT" ]; then
        ViashError '--input' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_OUTPUT" ]; then
        ViashError '--output' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_MIN_DIST" ]; then
        VIASH_PAR_MIN_DIST="0.5"
      fi
      if [ -z "$VIASH_PAR_ALPHA" ]; then
        VIASH_PAR_ALPHA="1.0"
      fi
      if [ -z "$VIASH_PAR_GAMMA" ]; then
        VIASH_PAR_GAMMA="1.0"
      fi
      if [ -z "$VIASH_PAR_RANDOM_SEED" ]; then
        VIASH_PAR_RANDOM_SEED="0"
      fi
      if [ -z "$VIASH_PAR_NEGATIVE_SAMPLE_RATE" ]; then
        VIASH_PAR_NEGATIVE_SAMPLE_RATE="5"
      fi
      if [ -z "$VIASH_PAR_INIT_POS" ]; then
        VIASH_PAR_INIT_POS="spectral"
      fi
      
      
      cat << VIASHEOF | bash
      set -e
      tempscript=\$(mktemp "$VIASH_TEMP/viash-run-umap-XXXXXX")
      function clean_up {
        rm "\$tempscript"
      }
      trap clean_up EXIT
      cat > "\$tempscript" << 'VIASHMAIN'
      # The following code has been auto-generated by Viash.
      par = {
        'input': $( if [ ! -z ${VIASH_PAR_INPUT+x} ]; then echo "'$VIASH_PAR_INPUT'"; else echo None; fi ),
        'output': $( if [ ! -z ${VIASH_PAR_OUTPUT+x} ]; then echo "'$VIASH_PAR_OUTPUT'"; else echo None; fi ),
        'min_dist': $( if [ ! -z ${VIASH_PAR_MIN_DIST+x} ]; then echo "float('$VIASH_PAR_MIN_DIST')"; else echo None; fi ),
        'alpha': $( if [ ! -z ${VIASH_PAR_ALPHA+x} ]; then echo "float('$VIASH_PAR_ALPHA')"; else echo None; fi ),
        'gamma': $( if [ ! -z ${VIASH_PAR_GAMMA+x} ]; then echo "float('$VIASH_PAR_GAMMA')"; else echo None; fi ),
        'random_seed': $( if [ ! -z ${VIASH_PAR_RANDOM_SEED+x} ]; then echo "int('$VIASH_PAR_RANDOM_SEED')"; else echo None; fi ),
        'negative_sample_rate': $( if [ ! -z ${VIASH_PAR_NEGATIVE_SAMPLE_RATE+x} ]; then echo "int('$VIASH_PAR_NEGATIVE_SAMPLE_RATE')"; else echo None; fi ),
        'init_pos': $( if [ ! -z ${VIASH_PAR_INIT_POS+x} ]; then echo "'$VIASH_PAR_INIT_POS'"; else echo None; fi )
      }
      
      resources_dir = '$VIASH_RESOURCES_DIR'
      
      ### VIASH START
      ### VIASH END
      
      import scanpy as sc
      
      data = sc.read_h5ad(par["input"])
      
      sc.tl.umap(data, 
                min_dist = par["min_dist"],
                alpha = par["alpha"],
                gamma = par["gamma"],
                random_state = par["random_seed"],
                negative_sample_rate = par["negative_sample_rate"],
                init_pos = par["init_pos"])
      
      data.write_h5ad(par["output"], compression = "gzip")
      VIASHMAIN
      PATH="$VIASH_RESOURCES_DIR:\$PATH"
      
      python "\$tempscript"
      
      VIASHEOF
      

    dest: "umap"
    is_executable: true
  - type: "file"
    text: |
        docker.enabled = true
        docker.runOptions = "-i -v ${baseDir}:${baseDir}"
        process.container = "dataintuitive/viash"
        params {
          umap__input = "viash_no_value"
          umap__output = "viash_no_value"
          umap__min_dist = "0.5"
          umap__alpha = "1.0"
          umap__gamma = "1.0"
          umap__random_seed = "0"
          umap__negative_sample_rate = "5"
          umap__init_pos = "spectral"
          id = ""
          testScript = "run_test.sh"
          testResources = [ "run_test.sh", "../../../resources/test/pbmc_1k_protein_v3_filtered_feature_bc_matrix.norm.hvg.pca.nn.umap.h5ad" ]
          umap {
            name = "umap"
            container = "projection_umap"
            containerTag = "main_build"
            containerRegistry = "openpipeline"
            command = "umap"
            tests {
              isDefined = true
              testScript = "run_test.sh"
              testResources = [ "run_test.sh", "../../../resources/test/pbmc_1k_protein_v3_filtered_feature_bc_matrix.norm.hvg.pca.nn.umap.h5ad" ]
            }
            arguments {
              input {
                name = "input"
                otype = "--"
                required = true
                type = "file"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.umap__input}"
                description = "Input h5ad file"
              }
              output {
                name = "output"
                otype = "--"
                required = true
                type = "file"
                direction = "Output"
                multiple = false
                multiple_sep = ":"
                value = "${params.umap__output}"
                description = "Output h5ad file."
              }
              min_dist {
                name = "min_dist"
                otype = "--"
                required = false
                type = "double"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.umap__min_dist}"
                dflt = "0.5"
                description = "The effective minimum distance between embedded points. Smaller values will result in a more clustered/clumped embedding where nearby points on the manifold are drawn closer together, while larger values will result on a more even dispersal of points. The value should be set relative to the spread value, which determines the scale at which embedded points will be spread out. The default of in the umap-learn package is 0.1."
              }
              alpha {
                name = "alpha"
                otype = "--"
                required = false
                type = "double"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.umap__alpha}"
                dflt = "1.0"
                description = "The initial learning rate for the embedding optimization."
              }
              gamma {
                name = "gamma"
                otype = "--"
                required = false
                type = "double"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.umap__gamma}"
                dflt = "1.0"
                description = "Weighting applied to negative samples in low dimensional embedding optimization. Values higher than one will result in greater weight being given to negative samples."
              }
              random_seed {
                name = "random_seed"
                otype = "--"
                required = false
                type = "integer"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.umap__random_seed}"
                dflt = "0"
                description = "Random seed for Leiden algrithm."
              }
              negative_sample_rate {
                name = "negative_sample_rate"
                otype = "--"
                required = false
                type = "integer"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.umap__negative_sample_rate}"
                dflt = "5"
                description = "The number of negative edge/1-simplex samples to use per positive edge/1-simplex sample in optimizing the low dimensional embedding."
              }
              init_pos {
                name = "init_pos"
                otype = "--"
                required = false
                type = "string"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.umap__init_pos}"
                dflt = "spectral"
                description = "How to initialize the low dimensional embedding. Called init in the original UMAP. Options are paga, spectral and random."
              }
            }
          }
        }

    dest: "nextflow.config"
  - type: "file"
    text: |
      nextflow.enable.dsl=2
      
      params.test = false
      params.debug = false
      params.publishDir = "./"
      
      // A function to verify (at runtime) if all required arguments are effectively provided.
      def checkParams(_params) {
        _params.arguments.collect{
          if (it.value == "viash_no_value") {
            println("[ERROR] option --${it.name} not specified in component umap")
            println("exiting now...")
              exit 1
          }
        }
      }
      
      
      def escape(str) {
        return str.replaceAll('\\\\', '\\\\\\\\').replaceAll("\"", "\\\\\"").replaceAll("\n", "\\\\n").replaceAll("`", "\\\\`")
      }
      
      def renderCLI(command, arguments) {
      
        def argumentsList = arguments.collect{ it ->
          (it.otype == "")
            ? "\'" + escape(it.value) + "\'"
            : (it.type == "boolean_true")
              ? it.otype + it.name
              : (it.value == "no_default_value_configured")
                ? ""
                : it.otype + it.name + " \'" + escape((it.value in List && it.multiple) ? it.value.join(it.multiple_sep): it.value) + "\'"
        }
      
        def command_line = command + argumentsList
      
        return command_line.join(" ")
      }
      
      def effectiveContainer(processParams) {
        def _registry = params.containsKey("containerRegistry") ? params.containerRegistry : processParams.containerRegistry
        def _name = processParams.container
        def _tag = params.containsKey("containerTag") ? params.containerTag : processParams.containerTag
      
        return (_registry == "" ? "" : _registry + "/") + _name + ":" + _tag
      }
      
      // Convert the nextflow.config arguments list to a List instead of a LinkedHashMap
      // The rest of this main.nf script uses the Map form
      def argumentsAsList(_params) {
        def overrideArgs = _params.arguments.collect{ key, value -> value }
        def newParams = _params + [ "arguments" : overrideArgs ]
        return newParams
      }
      
      
      // Use the params map, create a hashmap of the filenames for output
      // output filename is <sample>.<method>.<arg_name>[.extension]
      def outFromIn(_params) {
      
        def id = _params.id
      
        _params
          .arguments
          .findAll{ it -> it.type == "file" && it.direction == "Output" }
          .collect{ it ->
            // If an 'example' attribute is present, strip the extension from the filename,
            // If a 'dflt' attribute is present, strip the extension from the filename,
            // Otherwise just use the option name as an extension.
            def extOrName =
              (it.example != null)
                ? it.example.split(/\./).last()
                : (it.dflt != null)
                  ? it.dflt.split(/\./).last()
                  : it.name
            // The output filename is <sample> . <modulename> . <extension>
            // Unless the output argument is explicitly specified on the CLI
            def newValue =
              (it.value == "viash_no_value")
                ? "umap" + "." + extOrName
                : it.value
            def newName =
              (id != "")
                ? id + "." + newValue
                : newValue
            it + [ value : newName ]
          }
      
      }
      
      // A process that filters out output from the output Map
      process filterOutput {
      
        input:
          tuple val(id), val(input), val(_params)
        output:
          tuple val(id), val(output), val(_params)
        when:
          input.keySet().contains("output")
        exec:
          output = input["output"]
      
      }
      
      def overrideIO(_params, inputs, outputs) {
      
        // `inputs` in fact can be one of:
        // - `String`,
        // - `List[String]`,
        // - `Map[String, String | List[String]]`
        // Please refer to the docs for more info
        def overrideArgs = _params.arguments.collect{ it ->
          if (it.type == "file") {
            if (it.direction == "Input") {
              (inputs in List || inputs in HashMap)
                ? (inputs in List)
                  ? it + [ "value" : inputs.join(it.multiple_sep)]
                  : (inputs[it.name] != null)
                    ? (inputs[it.name] in List)
                      ? it + [ "value" : inputs[it.name].join(it.multiple_sep)]
                      : it + [ "value" : inputs[it.name]]
                    : it
                : it + [ "value" : inputs ]
            } else {
              (outputs in List || outputs in HashMap)
                ? (outputs in List)
                  ? it + [ "value" : outputs.join(it.multiple_sep)]
                  : (outputs[it.name] != null)
                    ? (outputs[it.name] in List)
                      ? it + [ "value" : outputs[it.name].join(it.multiple_sep)]
                      : it + [ "value" : outputs[it.name]]
                    : it
                : it + [ "value" : outputs ]
            }
          } else {
            it
          }
        }
      
        def newParams = _params + [ "arguments" : overrideArgs ]
      
        return newParams
      
      }
      
      process umap_process {
      
        label 'highcpu'
        tag "${id}"
        echo { (params.debug == true) ? true : false }
        cache 'deep'
        stageInMode "symlink"
        container "${container}"
      
        input:
          tuple val(id), path(input), val(output), val(container), val(cli), val(_params)
        output:
          tuple val("${id}"), path(output), val(_params)
        stub:
          """
          # Adding NXF's `$moduleDir` to the path in order to resolve our own wrappers
          export PATH="${moduleDir}:\$PATH"
          STUB=1 $cli
          """
        script:
          if (params.test)
            """
            # Some useful stuff
            export NUMBA_CACHE_DIR=/tmp/numba-cache
            # Running the pre-hook when necessary
            # Adding NXF's `$moduleDir` to the path in order to resolve our own wrappers
            export PATH="./:${moduleDir}:\$PATH"
            ./${params.umap.tests.testScript} | tee $output
            """
          else
            """
            # Some useful stuff
            export NUMBA_CACHE_DIR=/tmp/numba-cache
            # Running the pre-hook when necessary
            # Adding NXF's `$moduleDir` to the path in order to resolve our own wrappers
            export PATH="${moduleDir}:\$PATH"
            $cli
            """
      }
      
      workflow umap {
      
        take:
        id_input_params_
      
        main:
      
        def key = "umap"
      
        def id_input_output_function_cli_params_ =
          id_input_params_.map{ id, input, _params ->
      
            // Start from the (global) params and overwrite with the (local) _params
            def defaultParams = params[key] ? params[key] : [:]
            def overrideParams = _params[key] ? _params[key] : [:]
            def updtParams = defaultParams + overrideParams
            // Convert to List[Map] for the arguments
            def newParams = argumentsAsList(updtParams) + [ "id" : id ]
      
            // Generate output filenames, out comes a Map
            def output = outFromIn(newParams)
      
            // The process expects Path or List[Path], Maps need to be converted
            def inputsForProcess =
              (input in HashMap)
                ? input.collect{ k, v -> v }.flatten()
                : input
            def outputsForProcess = output.collect{ it.value }
      
            // For our machinery, we convert Path -> String in the input
            def inputs =
              (input in List || input in HashMap)
                ? (input in List)
                  ? input.collect{ it.name }
                  : input.collectEntries{ k, v -> [ k, (v in List) ? v.collect{it.name} : v.name ] }
                : input.name
            outputs = output.collectEntries{ [(it.name): it.value] }
      
            def finalParams = overrideIO(newParams, inputs, outputs)
      
            checkParams(finalParams)
      
            new Tuple6(
              id,
              inputsForProcess,
              outputsForProcess,
              effectiveContainer(finalParams),
              renderCLI([finalParams.command], finalParams.arguments),
              finalParams
              )
          }
      
        result_ = umap_process(id_input_output_function_cli_params_) \
          | join(id_input_params_) \
          | map{ id, output, _params, input, original_params ->
              def parsedOutput = _params.arguments
                .findAll{ it.type == "file" && it.direction == "Output" }
                .withIndex()
                .collectEntries{ it, i ->
                  // with one entry, output is of type Path and array selections
                  // would select just one element from the path
                  [(it.name): (output in List) ? output[i] : output ]
                }
              new Tuple3(id, parsedOutput, original_params)
            }
      
        result_ \
          | filter { it[1].keySet().size() > 1 } \
          | view{
              ">> Be careful, multiple outputs from this component!"
          }
      
        emit:
        result_.flatMap{ it ->
          (it[1].keySet().size() > 1)
            ? it[1].collect{ k, el -> [ it[0], [ (k): el ], it[2] ] }
            : it[1].collect{ k, el -> [ it[0], el, it[2] ] }
        }
      }
      
      workflow {
        def id = params.id
        def fname = "umap"
      
        def _params = params
      
        // could be refactored to be FP
        for (entry in params[fname].arguments) {
          def name = entry.value.name
          if (params[name] != null) {
            params[fname].arguments[name].value = params[name]
          }
        }
      
        def inputFiles = params.umap
          .arguments
          .findAll{ key, par -> par.type == "file" && par.direction == "Input" }
          .collectEntries{ key, par -> [(par.name): file(params[fname].arguments[par.name].value) ] }
      
        def ch_ = Channel.from("").map{ s -> new Tuple3(id, inputFiles, params)}
      
        result = umap(ch_)
        result.view{ it[1] }
      }
      
      // This workflow is not production-ready yet, we leave it in for future dev
      // TODO
      workflow test {
      
        take:
        rootDir
      
        main:
        params.test = true
        params.umap.output = "umap.log"
      
        Channel.from(rootDir) \
          | filter { params.umap.tests.isDefined } \
          | map{ p -> new Tuple3(
              "tests",
              params.umap.tests.testResources.collect{ file( p + it ) },
              params
          )} \
          | umap
      
        emit:
        umap.out
      }

    dest: "main.nf"
  description: "UMAP(Uniform Manifold Approximation and Projection) is a novel manifold\
    \ learning technique for dimension reduction. UMAP is constructed from a theoretical\
    \ framework based in Riemannian geometry and algebraic topology. The result is\
    \ a practical scalable algorithm that applies to real world data. The UMAP algorithm\
    \ is competitive with t-SNE for visualization quality, and arguably preserves\
    \ more of the global structure with superior run time performance. Furthermore,\
    \ UMAP has no computational restrictions on embedding dimension, making it viable\
    \ as a general purpose dimension reduction technique for machine learning. \n\n\
    For more information about the method see https://arxiv.org/abs/1802.03426\n"
  tests:
  - type: "bash_script"
    path: "run_test.sh"
    is_executable: true
  - type: "file"
    path: "../../../resources/test/pbmc_1k_protein_v3_filtered_feature_bc_matrix.norm.hvg.pca.nn.umap.h5ad"
  info: {}
platform:
  type: "nextflow"
  id: "nextflow"
  registry: "openpipeline"
  namespace_separator: "_"
  label: "highcpu"
  labels: []
platforms: []
info:
  config: "src/dimred/umap/config.vsh.yaml"
  platform: "nextflow"
  output: "target/nextflow/projection/umap"
  executable: "target/nextflow/projection/umap/umap"
  viash_version: "0.5.0"
  git_commit: "d5edae2a32d244cf4bc141449b93b72980bfd017"
  git_remote: "https://github.com/openpipelines-bio/openpipeline"
