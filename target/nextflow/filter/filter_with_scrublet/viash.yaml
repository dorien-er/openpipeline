functionality:
  name: "filter_with_scrublet"
  namespace: "filter"
  version: "main_build"
  authors:
  - name: "Dries De Maeyer"
    email: "DDeMaey1@its.jnj.com"
    roles:
    - "maintainer"
    props:
      account: "ddemaey1"
  - name: "Robrecht Cannoodt"
    email: "rcannood@gmail.com"
    roles:
    - "contributor"
    props:
      github: "rcannood"
      orcid: "0000-0003-3641-729X"
  arguments:
  - type: "file"
    name: "--input"
    alternatives: []
    description: "Input h5mu file"
    example: "input.h5mu"
    must_exist: false
    required: true
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "string"
    name: "--modality"
    alternatives: []
    default: "rna"
    required: false
    direction: "Input"
    multiple: true
    multiple_sep: ":"
  - type: "file"
    name: "--output"
    alternatives: []
    description: "Output h5mu file."
    example: "output.h5mu"
    must_exist: false
    required: false
    direction: "Output"
    multiple: false
    multiple_sep: ":"
  - type: "string"
    name: "--obs_name_filter"
    alternatives: []
    description: "In which .obs slot to store a boolean array corresponding to which\
      \ observations should be filtered out."
    default: "filter_with_scrublet"
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "boolean_true"
    name: "--do_subset"
    alternatives: []
    description: "Whether to subset before storing the output."
    direction: "Input"
  - type: "string"
    name: "--obs_name_doublet_score"
    alternatives: []
    description: "Name of the doublet scores column in the obs slot of the returned\
      \ object."
    default: "scrublet_doublet_score"
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--min_counts"
    alternatives: []
    description: "The number of minimal UMI counts per cell that have to be present\
      \ for initial cell detection."
    default: 2
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--min_cells"
    alternatives: []
    description: "The number of cells in which UMIs for a gene were detected."
    default: 3
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--min_gene_variablity_percent"
    alternatives: []
    description: "Used for gene filtering prior to PCA. Keep the most highly variable\
      \ genes (in the top min_gene_variability_pctl percentile), as measured by the\
      \ v-statistic [Klein et al., Cell 2015]."
    default: 85.0
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--num_pca_components"
    alternatives: []
    description: "Number of principal components to use during PCA dimensionality\
      \ reduction."
    default: 30
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  - type: "string"
    name: "--distance_metric"
    alternatives: []
    description: "The distance metric used for computing similarities."
    default: "euclidean"
    required: false
    direction: "Input"
    multiple: false
    multiple_sep: ":"
  resources:
  - type: "bash_script"
    text: |
      #!/usr/bin/env bash
      
      #########################################
      #    filter_with_scrublet main_build    #
      #########################################
      
      # This wrapper script is auto-generated by viash 0.5.10 and is thus a derivative
      # work thereof. This software comes with ABSOLUTELY NO WARRANTY from Data
      # Intuitive.  The component may contain files which fall under a different
      # license. The authors of this component should specify the license in the
      # header of such files, or include a separate license file detailing the
      # licenses of all included files.
      #
      # Component authors:
      # * Dries De Maeyer <DDeMaey1@its.jnj.com> (maintainer) {account: ddemaey1}
      # * Robrecht Cannoodt <rcannood@gmail.com> (contributor) {github: rcannood, orcid: 0000-0003-3641-729X}
      
      set -e
      
      if [ -z "$VIASH_TEMP" ]; then
        VIASH_TEMP=/tmp
      fi
      
      # define helper functions
      # ViashQuote: put quotes around non flag values
      # $1     : unquoted string
      # return : possibly quoted string
      # examples:
      #   ViashQuote --foo      # returns --foo
      #   ViashQuote bar        # returns 'bar'
      #   Viashquote --foo=bar  # returns --foo='bar'
      function ViashQuote {
        if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
          echo "$1" | sed "s#=\(.*\)#='\1'#"
        elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
          echo "$1"
        else
          echo "'$1'"
        fi
      }
      # ViashRemoveFlags: Remove leading flag
      # $1     : string with a possible leading flag
      # return : string without possible leading flag
      # examples:
      #   ViashRemoveFlags --foo=bar  # returns bar
      function ViashRemoveFlags {
        echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
      }
      # ViashSourceDir: return the path of a bash file, following symlinks
      # usage   : ViashSourceDir ${BASH_SOURCE[0]}
      # $1      : Should always be set to ${BASH_SOURCE[0]}
      # returns : The absolute path of the bash file
      function ViashSourceDir {
        SOURCE="$1"
        while [ -h "$SOURCE" ]; do
          DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
          SOURCE="$(readlink "$SOURCE")"
          [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
        done
        cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
      }
      # see https://en.wikipedia.org/wiki/Syslog#Severity_level
      VIASH_LOGCODE_EMERGENCY=0
      VIASH_LOGCODE_ALERT=1
      VIASH_LOGCODE_CRITICAL=2
      VIASH_LOGCODE_ERROR=3
      VIASH_LOGCODE_WARNING=4
      VIASH_LOGCODE_NOTICE=5
      VIASH_LOGCODE_INFO=6
      VIASH_LOGCODE_DEBUG=7
      VIASH_VERBOSITY=$VIASH_LOGCODE_NOTICE
      
      # ViashLog: Log events depending on the verbosity level
      # usage: ViashLog 1 alert Oh no something went wrong!
      # $1: required verbosity level
      # $2: display tag
      # $3+: messages to display
      # stdout: Your input, prepended by '[$2] '.
      function ViashLog {
        local required_level="$1"
        local display_tag="$2"
        shift 2
        if [ $VIASH_VERBOSITY -ge $required_level ]; then
          echo "[$display_tag]" "$@"
        fi
      }
      
      # ViashEmergency: log events when the system is unstable
      # usage: ViashEmergency Oh no something went wrong.
      # stdout: Your input, prepended by '[emergency] '.
      function ViashEmergency {
        ViashLog $VIASH_LOGCODE_EMERGENCY emergency $@
      }
      
      # ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
      # usage: ViashAlert Oh no something went wrong.
      # stdout: Your input, prepended by '[alert] '.
      function ViashAlert {
        ViashLog $VIASH_LOGCODE_ALERT alert $@
      }
      
      # ViashCritical: log events when a critical condition occurs
      # usage: ViashCritical Oh no something went wrong.
      # stdout: Your input, prepended by '[critical] '.
      function ViashCritical {
        ViashLog $VIASH_LOGCODE_CRITICAL critical $@
      }
      
      # ViashError: log events when an error condition occurs
      # usage: ViashError Oh no something went wrong.
      # stdout: Your input, prepended by '[error] '.
      function ViashError {
        ViashLog $VIASH_LOGCODE_ERROR error $@
      }
      
      # ViashWarning: log potentially abnormal events
      # usage: ViashWarning Something may have gone wrong.
      # stdout: Your input, prepended by '[warning] '.
      function ViashWarning {
        ViashLog $VIASH_LOGCODE_WARNING warning $@
      }
      
      # ViashNotice: log significant but normal events
      # usage: ViashNotice This just happened.
      # stdout: Your input, prepended by '[notice] '.
      function ViashNotice {
        ViashLog $VIASH_LOGCODE_NOTICE notice $@
      }
      
      # ViashInfo: log normal events
      # usage: ViashInfo This just happened.
      # stdout: Your input, prepended by '[info] '.
      function ViashInfo {
        ViashLog $VIASH_LOGCODE_INFO info $@
      }
      
      # ViashDebug: log all events, for debugging purposes
      # usage: ViashDebug This just happened.
      # stdout: Your input, prepended by '[debug] '.
      function ViashDebug {
        ViashLog $VIASH_LOGCODE_DEBUG debug $@
      }
      
      # find source folder of this component
      VIASH_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`
      
      # define meta fields
      VIASH_META_FUNCTIONALITY_NAME="filter_with_scrublet"
      
      
      # ViashHelp: Display helpful explanation about this executable
      function ViashHelp {
        echo "filter_with_scrublet main_build"
        echo "Doublet detection using the Scrublet method (Wolock, Lopez and Klein, 2019)."
        echo "The method tests for potential doublets by using the expression profiles of"
        echo "cells to generate synthetic potential doubles which are tested against cells. "
        echo "The method returns a \"doublet score\" on which it calls for potential doublets."
        echo ""
        echo "For the source code please visit https://github.com/AllonKleinLab/scrublet."
        echo ""
        echo "For 10x we expect the doublet rates to be:"
        echo "  Multiplet Rate (%) - # of Cells Loaded - # of Cells Recovered"
        echo "  ~0.4% ~800 ~500"
        echo "  ~0.8% ~1,600 ~1,000"
        echo "  ~1.6% ~3,200 ~2,000"
        echo "  ~2.3% ~4,800 ~3,000"
        echo "  ~3.1% ~6,400 ~4,000"
        echo "  ~3.9% ~8,000 ~5,000"
        echo "  ~4.6% ~9,600 ~6,000"
        echo "  ~5.4% ~11,200 ~7,000"
        echo "  ~6.1% ~12,800 ~8,000"
        echo "  ~6.9% ~14,400 ~9,000"
        echo "  ~7.6% ~16,000 ~10,000"
        echo
        echo "Options:"
      
        echo "   --input"
        echo "        type: file, required parameter"
        echo "        example: input.h5mu"
        echo "        Input h5mu file"
        echo ""
      
      
        echo "   --modality"
        echo "        type: string, multiple values allowed"
        echo "        default: rna"
        echo ""
      
      
        echo "   --output"
        echo "        type: file, output"
        echo "        example: output.h5mu"
        echo "        Output h5mu file."
        echo ""
      
      
        echo "   --obs_name_filter"
        echo "        type: string"
        echo "        default: filter_with_scrublet"
        echo "        In which .obs slot to store a boolean array corresponding to which observations should be filtered out."
        echo ""
      
      
        echo "   --do_subset"
        echo "        type: boolean_true"
        echo "        Whether to subset before storing the output."
        echo ""
      
      
        echo "   --obs_name_doublet_score"
        echo "        type: string"
        echo "        default: scrublet_doublet_score"
        echo "        Name of the doublet scores column in the obs slot of the returned object."
        echo ""
      
      
        echo "   --min_counts"
        echo "        type: integer"
        echo "        default: 2"
        echo "        The number of minimal UMI counts per cell that have to be present for initial cell detection."
        echo ""
      
      
        echo "   --min_cells"
        echo "        type: integer"
        echo "        default: 3"
        echo "        The number of cells in which UMIs for a gene were detected."
        echo ""
      
      
        echo "   --min_gene_variablity_percent"
        echo "        type: double"
        echo "        default: 85.0"
        echo "        Used for gene filtering prior to PCA. Keep the most highly variable genes (in the top min_gene_variability_pctl percentile), as measured by the v-statistic [Klein et al., Cell 2015]."
        echo ""
      
      
        echo "   --num_pca_components"
        echo "        type: integer"
        echo "        default: 30"
        echo "        Number of principal components to use during PCA dimensionality reduction."
        echo ""
      
      
        echo "   --distance_metric"
        echo "        type: string"
        echo "        default: euclidean"
        echo "        The distance metric used for computing similarities."
        echo ""
      
      }
      
      # initialise array
      VIASH_POSITIONAL_ARGS=''
      VIASH_MODE='run'
      
      while [[ $# -gt 0 ]]; do
          case "$1" in
              -h|--help)
                  ViashHelp
                  exit
                  ;;
              ---v|---verbose)
                  let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
                  shift 1
                  ;;
              ---verbosity)
                  VIASH_VERBOSITY="$2"
                  shift 2
                  ;;
              ---verbosity=*)
                  VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
                  shift 1
                  ;;
              --version)
                  echo "filter_with_scrublet main_build"
                  exit
                  ;;
              --input)
                  VIASH_PAR_INPUT="$2"
                  shift 2
                  ;;
              --input=*)
                  VIASH_PAR_INPUT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --modality)
                  if [ -z "$VIASH_PAR_MODALITY" ]; then
                    VIASH_PAR_MODALITY="$2"
                  else
                    VIASH_PAR_MODALITY="$VIASH_PAR_MODALITY:""$2"
                  fi
                  shift 2
                  ;;
              --modality=*)
                  if [ -z "$VIASH_PAR_MODALITY" ]; then
                    VIASH_PAR_MODALITY=$(ViashRemoveFlags "$1")
                  else
                    VIASH_PAR_MODALITY="$VIASH_PAR_MODALITY:"$(ViashRemoveFlags "$1")
                  fi
                  shift 1
                  ;;
              --output)
                  VIASH_PAR_OUTPUT="$2"
                  shift 2
                  ;;
              --output=*)
                  VIASH_PAR_OUTPUT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --obs_name_filter)
                  VIASH_PAR_OBS_NAME_FILTER="$2"
                  shift 2
                  ;;
              --obs_name_filter=*)
                  VIASH_PAR_OBS_NAME_FILTER=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --do_subset)
                  VIASH_PAR_DO_SUBSET=true
                  shift 1
                  ;;
              --obs_name_doublet_score)
                  VIASH_PAR_OBS_NAME_DOUBLET_SCORE="$2"
                  shift 2
                  ;;
              --obs_name_doublet_score=*)
                  VIASH_PAR_OBS_NAME_DOUBLET_SCORE=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --min_counts)
                  VIASH_PAR_MIN_COUNTS="$2"
                  shift 2
                  ;;
              --min_counts=*)
                  VIASH_PAR_MIN_COUNTS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --min_cells)
                  VIASH_PAR_MIN_CELLS="$2"
                  shift 2
                  ;;
              --min_cells=*)
                  VIASH_PAR_MIN_CELLS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --min_gene_variablity_percent)
                  VIASH_PAR_MIN_GENE_VARIABLITY_PERCENT="$2"
                  shift 2
                  ;;
              --min_gene_variablity_percent=*)
                  VIASH_PAR_MIN_GENE_VARIABLITY_PERCENT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --num_pca_components)
                  VIASH_PAR_NUM_PCA_COMPONENTS="$2"
                  shift 2
                  ;;
              --num_pca_components=*)
                  VIASH_PAR_NUM_PCA_COMPONENTS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --distance_metric)
                  VIASH_PAR_DISTANCE_METRIC="$2"
                  shift 2
                  ;;
              --distance_metric=*)
                  VIASH_PAR_DISTANCE_METRIC=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              *)  # positional arg or unknown option
                  # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
                  VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
                  shift # past argument
                  ;;
          esac
      done
      
      # parse positional parameters
      eval set -- $VIASH_POSITIONAL_ARGS
      
      
      
      
      # check whether required parameters exist
      if [ -z "$VIASH_PAR_INPUT" ]; then
        ViashError '--input' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_MODALITY" ]; then
        VIASH_PAR_MODALITY="rna"
      fi
      if [ -z "$VIASH_PAR_OBS_NAME_FILTER" ]; then
        VIASH_PAR_OBS_NAME_FILTER="filter_with_scrublet"
      fi
      if [ -z "$VIASH_PAR_DO_SUBSET" ]; then
        VIASH_PAR_DO_SUBSET="false"
      fi
      if [ -z "$VIASH_PAR_OBS_NAME_DOUBLET_SCORE" ]; then
        VIASH_PAR_OBS_NAME_DOUBLET_SCORE="scrublet_doublet_score"
      fi
      if [ -z "$VIASH_PAR_MIN_COUNTS" ]; then
        VIASH_PAR_MIN_COUNTS="2"
      fi
      if [ -z "$VIASH_PAR_MIN_CELLS" ]; then
        VIASH_PAR_MIN_CELLS="3"
      fi
      if [ -z "$VIASH_PAR_MIN_GENE_VARIABLITY_PERCENT" ]; then
        VIASH_PAR_MIN_GENE_VARIABLITY_PERCENT="85.0"
      fi
      if [ -z "$VIASH_PAR_NUM_PCA_COMPONENTS" ]; then
        VIASH_PAR_NUM_PCA_COMPONENTS="30"
      fi
      if [ -z "$VIASH_PAR_DISTANCE_METRIC" ]; then
        VIASH_PAR_DISTANCE_METRIC="euclidean"
      fi
      
      
      cat << VIASHEOF | bash
      set -e
      tempscript=\$(mktemp "$VIASH_TEMP/viash-run-filter_with_scrublet-XXXXXX")
      function clean_up {
        rm "\$tempscript"
      }
      function interrupt {
        echo -e "\nCTRL-C Pressed..."
        exit 1
      }
      trap clean_up EXIT
      trap interrupt INT SIGINT
      cat > "\$tempscript" << 'VIASHMAIN'
      import scrublet as scr
      import muon as mu
      import numpy as np
      
      ### VIASH START
      # The following code has been auto-generated by Viash.
      par = {
        'input': $( if [ ! -z ${VIASH_PAR_INPUT+x} ]; then echo "'$VIASH_PAR_INPUT'"; else echo None; fi ),
        'modality': $( if [ ! -z ${VIASH_PAR_MODALITY+x} ]; then echo "'$VIASH_PAR_MODALITY'.split(':')"; else echo None; fi ),
        'output': $( if [ ! -z ${VIASH_PAR_OUTPUT+x} ]; then echo "'$VIASH_PAR_OUTPUT'"; else echo None; fi ),
        'obs_name_filter': $( if [ ! -z ${VIASH_PAR_OBS_NAME_FILTER+x} ]; then echo "'$VIASH_PAR_OBS_NAME_FILTER'"; else echo None; fi ),
        'do_subset': $( if [ ! -z ${VIASH_PAR_DO_SUBSET+x} ]; then echo "'$VIASH_PAR_DO_SUBSET'.lower() == 'true'"; else echo None; fi ),
        'obs_name_doublet_score': $( if [ ! -z ${VIASH_PAR_OBS_NAME_DOUBLET_SCORE+x} ]; then echo "'$VIASH_PAR_OBS_NAME_DOUBLET_SCORE'"; else echo None; fi ),
        'min_counts': $( if [ ! -z ${VIASH_PAR_MIN_COUNTS+x} ]; then echo "int('$VIASH_PAR_MIN_COUNTS')"; else echo None; fi ),
        'min_cells': $( if [ ! -z ${VIASH_PAR_MIN_CELLS+x} ]; then echo "int('$VIASH_PAR_MIN_CELLS')"; else echo None; fi ),
        'min_gene_variablity_percent': $( if [ ! -z ${VIASH_PAR_MIN_GENE_VARIABLITY_PERCENT+x} ]; then echo "float('$VIASH_PAR_MIN_GENE_VARIABLITY_PERCENT')"; else echo None; fi ),
        'num_pca_components': $( if [ ! -z ${VIASH_PAR_NUM_PCA_COMPONENTS+x} ]; then echo "int('$VIASH_PAR_NUM_PCA_COMPONENTS')"; else echo None; fi ),
        'distance_metric': $( if [ ! -z ${VIASH_PAR_DISTANCE_METRIC+x} ]; then echo "'$VIASH_PAR_DISTANCE_METRIC'"; else echo None; fi )
      }
      meta = {
        'functionality_name': '$VIASH_META_FUNCTIONALITY_NAME',
        'resources_dir': '$VIASH_RESOURCES_DIR'
      }
      
      resources_dir = '$VIASH_RESOURCES_DIR'
      
      ### VIASH END
      
      print(f"Reading {par['input']}")
      mdata = mu.read_h5mu(par["input"])
      
      for mod in par["modality"]:
          print(f"Processing modality '{mod}'")
          data = mdata.mod[mod]
      
          print("Running scrublet")
          scrub = scr.Scrublet(data.X)
      
          doublet_scores, predicted_doublets = scrub.scrub_doublets(
              min_counts=par["min_counts"],
              min_cells=par["min_cells"],
              min_gene_variability_pctl=par["min_gene_variablity_percent"],
              n_prin_comps=par["num_pca_components"],
              distance_metric=par["distance_metric"],
          )
          keep_cells = np.invert(predicted_doublets)
      
          print("  Storing output into .obs")
          if par["obs_name_doublet_score"] is not None:
              data.obs[par["obs_name_doublet_score"]] = doublet_scores
          if par["obs_name_filter"] is not None:
              data.obs[par["obs_name_filter"]] = keep_cells
      
          if par["do_subset"]:
              mdata.mod[mod] = data[keep_cells, :]
      
      
      # # can we assume execution_log exists?
      # if mdata.uns is None or "execution_log" not in mdata.uns:
      #     mdata.uns["execution_log"] = []
      # # store new entry
      # new_entry = {"component": meta["functionality_name"], "params": par}
      # mdata.uns["execution_log"].append(new_entry)
      
      
      print("Writing h5mu to file")
      mdata.write_h5mu(par["output"])
      VIASHMAIN
      python "\$tempscript" &
      wait "\$!"
      
      VIASHEOF
      

    dest: "filter_with_scrublet"
    is_executable: true
  - type: "file"
    text: |
        docker.enabled = true
        def viash_temp = System.getenv("VIASH_TEMP") ?: "/tmp/"
        docker.runOptions = "-i -v ${baseDir}:${baseDir} -v $viash_temp:$viash_temp"
        process.container = "dataintuitive/viash"
        params {
          filter_with_scrublet__input = "viash_no_value"
          filter_with_scrublet__modality = "rna"
          filter_with_scrublet__output = "no_default_value_configured"
          filter_with_scrublet__obs_name_filter = "filter_with_scrublet"
          filter_with_scrublet__do_subset = "no_default_value_configured"
          filter_with_scrublet__obs_name_doublet_score = "scrublet_doublet_score"
          filter_with_scrublet__min_counts = "2"
          filter_with_scrublet__min_cells = "3"
          filter_with_scrublet__min_gene_variablity_percent = "85.0"
          filter_with_scrublet__num_pca_components = "30"
          filter_with_scrublet__distance_metric = "euclidean"
          id = ""
          testScript = "run_test.py"
          testResources = [ "run_test.py", "../../../resources_test/pbmc_1k_protein_v3" ]
          filter_with_scrublet {
            name = "filter_with_scrublet"
            container = "filter_filter_with_scrublet"
            containerTag = "main_build"
            containerRegistry = "ghcr.io"
            command = "filter_with_scrublet"
            tests {
              isDefined = true
              testScript = "run_test.py"
              testResources = [ "run_test.py", "../../../resources_test/pbmc_1k_protein_v3" ]
            }
            arguments {
              input {
                name = "input"
                otype = "--"
                required = true
                type = "file"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__input}"
                example = "input.h5mu"
                description = "Input h5mu file"
              }
              modality {
                name = "modality"
                otype = "--"
                required = false
                type = "string"
                direction = "Input"
                multiple = true
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__modality}"
                dflt = "rna"
              }
              output {
                name = "output"
                otype = "--"
                required = false
                type = "file"
                direction = "Output"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__output}"
                example = "output.h5mu"
                description = "Output h5mu file."
              }
              obs_name_filter {
                name = "obs_name_filter"
                otype = "--"
                required = false
                type = "string"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__obs_name_filter}"
                dflt = "filter_with_scrublet"
                description = "In which .obs slot to store a boolean array corresponding to which observations should be filtered out."
              }
              do_subset {
                name = "do_subset"
                otype = "--"
                required = false
                type = "boolean_true"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__do_subset}"
                description = "Whether to subset before storing the output."
              }
              obs_name_doublet_score {
                name = "obs_name_doublet_score"
                otype = "--"
                required = false
                type = "string"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__obs_name_doublet_score}"
                dflt = "scrublet_doublet_score"
                description = "Name of the doublet scores column in the obs slot of the returned object."
              }
              min_counts {
                name = "min_counts"
                otype = "--"
                required = false
                type = "integer"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__min_counts}"
                dflt = "2"
                description = "The number of minimal UMI counts per cell that have to be present for initial cell detection."
              }
              min_cells {
                name = "min_cells"
                otype = "--"
                required = false
                type = "integer"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__min_cells}"
                dflt = "3"
                description = "The number of cells in which UMIs for a gene were detected."
              }
              min_gene_variablity_percent {
                name = "min_gene_variablity_percent"
                otype = "--"
                required = false
                type = "double"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__min_gene_variablity_percent}"
                dflt = "85.0"
                description = "Used for gene filtering prior to PCA. Keep the most highly variable genes (in the top min_gene_variability_pctl percentile), as measured by the v-statistic [Klein et al., Cell 2015]."
              }
              num_pca_components {
                name = "num_pca_components"
                otype = "--"
                required = false
                type = "integer"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__num_pca_components}"
                dflt = "30"
                description = "Number of principal components to use during PCA dimensionality reduction."
              }
              distance_metric {
                name = "distance_metric"
                otype = "--"
                required = false
                type = "string"
                direction = "Input"
                multiple = false
                multiple_sep = ":"
                value = "${params.filter_with_scrublet__distance_metric}"
                dflt = "euclidean"
                description = "The distance metric used for computing similarities."
              }
            }
          }
        }

    dest: "nextflow.config"
  - type: "file"
    text: |
      nextflow.enable.dsl=2
      
      params.test = false
      params.debug = false
      params.publishDir = "./"
      
      // A function to verify (at runtime) if all required arguments are effectively provided.
      def checkParams(_params) {
        _params.arguments.collect{
          if (it.value == "viash_no_value") {
            println("[ERROR] option --${it.name} not specified in component filter_with_scrublet")
            println("exiting now...")
              exit 1
          }
        }
      }
      
      
      def escape(str) {
        return str.replaceAll('\\\\', '\\\\\\\\').replaceAll("\"", "\\\\\"").replaceAll("\n", "\\\\n").replaceAll("`", "\\\\`")
      }
      
      def renderArg(it) {
        if (it.otype == "") {
          return "'" + escape(it.value) + "'"
        } else if (it.type == "boolean_true") {
          if (it.value.toLowerCase() == "true") {
            return it.otype + it.name
          } else {
            return ""
          }
        } else if (it.type == "boolean_false") {
          if (it.value.toLowerCase() == "true") {
            return ""
          } else {
            return it.otype + it.name
          }
        } else if (it.value == "no_default_value_configured") {
          return ""
        } else {
          def retVal = it.value in List && it.multiple ? it.value.join(it.multiple_sep): it.value
          return it.otype + it.name + " '" + escape(retVal) + "'"
        }
      }
      
      def renderCLI(command, arguments) {
        def argumentsList = arguments.collect{renderArg(it)}.findAll{it != ""}
      
        def command_line = command + argumentsList
      
        return command_line.join(" ")
      }
      
      def effectiveContainer(processParams) {
        def _registry = params.containsKey("containerRegistry") ? params.containerRegistry : processParams.containerRegistry
        def _name = processParams.container
        def _tag = params.containsKey("containerTag") ? params.containerTag : processParams.containerTag
      
        return (_registry == "" ? "" : _registry + "/") + _name + ":" + _tag
      }
      
      // Convert the nextflow.config arguments list to a List instead of a LinkedHashMap
      // The rest of this main.nf script uses the Map form
      def argumentsAsList(_params) {
        def overrideArgs = _params.arguments.collect{ key, value -> value }
        def newParams = _params + [ "arguments" : overrideArgs ]
        return newParams
      }
      
      
      // Use the params map, create a hashmap of the filenames for output
      // output filename is <sample>.<method>.<arg_name>[.extension]
      def outFromIn(_params) {
      
        def id = _params.id
      
        _params
          .arguments
          .findAll{ it -> it.type == "file" && it.direction == "Output" }
          .collect{ it ->
            // If an 'example' attribute is present, strip the extension from the filename,
            // If a 'dflt' attribute is present, strip the extension from the filename,
            // Otherwise just use the option name as an extension.
            def extOrName =
              (it.example != null)
                ? it.example.split(/\./).last()
                : (it.dflt != null)
                  ? it.dflt.split(/\./).last()
                  : it.name
            // The output filename is <sample> . <modulename> . <extension>
            // Unless the output argument is explicitly specified on the CLI
            def newValue =
              (it.value == "viash_no_value")
                ? "filter_with_scrublet." + it.name + "." + extOrName
                : it.value
            def newName =
              (id != "")
                ? id + "." + newValue
                : it.name + newValue
            it + [ value : newName ]
          }
      
      }
      
      // A process that filters out output from the output Map
      process filterOutput {
      
        input:
          tuple val(id), val(input), val(_params)
        output:
          tuple val(id), val(output), val(_params)
        when:
          input.keySet().contains("output")
        exec:
          output = input["output"]
      
      }
      
      def overrideIO(_params, inputs, outputs) {
      
        // `inputs` in fact can be one of:
        // - `String`,
        // - `List[String]`,
        // - `Map[String, String | List[String]]`
        // Please refer to the docs for more info
        def overrideArgs = _params.arguments.collect{ it ->
          if (it.type == "file") {
            if (it.direction == "Input") {
              (inputs in List || inputs in HashMap)
                ? (inputs in List)
                  ? it + [ "value" : inputs.join(it.multiple_sep)]
                  : (inputs[it.name] != null)
                    ? (inputs[it.name] in List)
                      ? it + [ "value" : inputs[it.name].join(it.multiple_sep)]
                      : it + [ "value" : inputs[it.name]]
                    : it
                : it + [ "value" : inputs ]
            } else {
              (outputs in List || outputs in HashMap)
                ? (outputs in List)
                  ? it + [ "value" : outputs.join(it.multiple_sep)]
                  : (outputs[it.name] != null)
                    ? (outputs[it.name] in List)
                      ? it + [ "value" : outputs[it.name].join(it.multiple_sep)]
                      : it + [ "value" : outputs[it.name]]
                    : it
                : it + [ "value" : outputs ]
            }
          } else {
            it
          }
        }
      
        def newParams = _params + [ "arguments" : overrideArgs ]
      
        return newParams
      
      }
      
      process filter_with_scrublet_process {
        label 'highcpu'
        tag "${id}"
        echo { (params.debug == true) ? true : false }
        stageInMode "symlink"
        container "${container}"
      
        input:
          tuple val(id), path(input), val(output), val(container), val(cli), val(_params)
        output:
          tuple val("${id}"), path(output), val(_params)
        stub:
          """
          # Adding NXF's `$moduleDir` to the path in order to resolve our own wrappers
          export PATH="${moduleDir}:\$PATH"
          STUB=1 $cli
          """
        script:
          def viash_temp = System.getenv("VIASH_TEMP") ?: "/tmp/"
          if (params.test)
            """
            # Some useful stuff
            export NUMBA_CACHE_DIR=/tmp/numba-cache
            # Running the pre-hook when necessary
            # Pass viash temp dir
            export VIASH_TEMP="${viash_temp}"
            # Adding NXF's `$moduleDir` to the path in order to resolve our own wrappers
            export PATH="./:${moduleDir}:\$PATH"
            ./${params.filter_with_scrublet.tests.testScript} | tee $output
            """
          else
            """
            # Some useful stuff
            export NUMBA_CACHE_DIR=/tmp/numba-cache
            # Running the pre-hook when necessary
            # Pass viash temp dir
            export VIASH_TEMP="${viash_temp}"
            # Adding NXF's `$moduleDir` to the path in order to resolve our own wrappers
            export PATH="${moduleDir}:\$PATH"
            $cli
            """
      }
      
      workflow filter_with_scrublet {
      
        take:
        id_input_params_
      
        main:
      
        def key = "filter_with_scrublet"
      
        def id_input_output_function_cli_params_ =
          id_input_params_.map{ id, input, _params ->
      
            // Start from the (global) params and overwrite with the (local) _params
            def defaultParams = params[key] ? params[key] : [:]
            def overrideParams = _params[key] ? _params[key] : [:]
            def updtParams = defaultParams + overrideParams
            // Convert to List[Map] for the arguments
            def newParams = argumentsAsList(updtParams) + [ "id" : id ]
      
            // Generate output filenames, out comes a Map
            def output = outFromIn(newParams)
      
            // The process expects Path or List[Path], Maps need to be converted
            def inputsForProcess =
              (input in HashMap)
                ? input.collect{ k, v -> v }.flatten()
                : input
            def outputsForProcess = output.collect{ it.value }
      
            // For our machinery, we convert Path -> String in the input
            def inputs =
              (input in List || input in HashMap)
                ? (input in List)
                  ? input.collect{ it.name }
                  : input.collectEntries{ k, v -> [ k, (v in List) ? v.collect{it.name} : v.name ] }
                : input.name
            outputs = output.collectEntries{ [(it.name): it.value] }
      
            def finalParams = overrideIO(newParams, inputs, outputs)
      
            checkParams(finalParams)
      
            new Tuple6(
              id,
              inputsForProcess,
              outputsForProcess,
              effectiveContainer(finalParams),
              renderCLI([finalParams.command], finalParams.arguments),
              finalParams
            )
          }
      
        result_ = filter_with_scrublet_process(id_input_output_function_cli_params_)
          | join(id_input_params_)
          | map{ id, output, _params, input, original_params ->
              def parsedOutput = _params.arguments
                .findAll{ it.type == "file" && it.direction == "Output" }
                .withIndex()
                .collectEntries{ it, i ->
                  // with one entry, output is of type Path and array selections
                  // would select just one element from the path
                  [(it.name): (output in List) ? output[i] : output ]
                }
              new Tuple3(id, parsedOutput, original_params)
            }
      
        result_
           | filter { it[1].keySet().size() > 1 }
           | view{">> Be careful, multiple outputs from this component!"}
      
        emit:
        result_.flatMap{ it ->
          (it[1].keySet().size() > 1)
            ? it[1].collect{ k, el -> [ it[0], [ (k): el ], it[2] ] }
            : it[1].collect{ k, el -> [ it[0], el, it[2] ] }
        }
      }
      
      workflow {
        def id = params.id
        def fname = "filter_with_scrublet"
      
        def _params = params
      
        // could be refactored to be FP
        for (entry in params[fname].arguments) {
          def name = entry.value.name
          if (params[name] != null) {
            params[fname].arguments[name].value = params[name]
          }
        }
      
        def inputFiles = params.filter_with_scrublet
          .arguments
          .findAll{ key, par -> par.type == "file" && par.direction == "Input" }
          .collectEntries{ key, par -> [(par.name): file(params[fname].arguments[par.name].value) ] }
      
        def ch_ = Channel.from("").map{ s -> new Tuple3(id, inputFiles, params)}
      
        result = filter_with_scrublet(ch_)
        result.view{ it[1] }
      }
      
      // This workflow is not production-ready yet, we leave it in for future dev
      // TODO
      workflow test {
      
        take:
        rootDir
      
        main:
        params.test = true
        params.filter_with_scrublet.output = "filter_with_scrublet.log"
      
        Channel.from(rootDir) \
          | filter { params.filter_with_scrublet.tests.isDefined } \
          | map{ p -> new Tuple3(
              "tests",
              params.filter_with_scrublet.tests.testResources.collect{ file( p + it ) },
              params
          )} \
          | filter_with_scrublet
      
        emit:
        filter_with_scrublet.out
      }

    dest: "main.nf"
  description: "Doublet detection using the Scrublet method (Wolock, Lopez and Klein,\
    \ 2019).\nThe method tests for potential doublets by using the expression profiles\
    \ of\ncells to generate synthetic potential doubles which are tested against cells.\
    \ \nThe method returns a \"doublet score\" on which it calls for potential doublets.\n\
    \nFor the source code please visit https://github.com/AllonKleinLab/scrublet.\n\
    \nFor 10x we expect the doublet rates to be:\n  Multiplet Rate (%) - # of Cells\
    \ Loaded - # of Cells Recovered\n  ~0.4% ~800 ~500\n  ~0.8% ~1,600 ~1,000\n  ~1.6%\
    \ ~3,200 ~2,000\n  ~2.3% ~4,800 ~3,000\n  ~3.1% ~6,400 ~4,000\n  ~3.9% ~8,000\
    \ ~5,000\n  ~4.6% ~9,600 ~6,000\n  ~5.4% ~11,200 ~7,000\n  ~6.1% ~12,800 ~8,000\n\
    \  ~6.9% ~14,400 ~9,000\n  ~7.6% ~16,000 ~10,000\n"
  tests:
  - type: "python_script"
    path: "run_test.py"
    is_executable: true
  - type: "file"
    path: "../../../resources_test/pbmc_1k_protein_v3"
  info: {}
  dummy_arguments: []
  set_wd_to_resources_dir: false
  add_resources_to_path: false
platform:
  type: "nextflow"
  id: "nextflow"
  registry: "ghcr.io"
  organization: "openpipeline"
  namespace_separator: "_"
  separate_multiple_outputs: true
  label: "highcpu"
  labels: []
platforms: []
info:
  config: "src/filter/filter_with_scrublet/config.vsh.yaml"
  platform: "nextflow"
  output: "target/nextflow/filter/filter_with_scrublet"
  executable: "target/nextflow/filter/filter_with_scrublet/filter_with_scrublet"
  viash_version: "0.5.10"
  git_commit: "d967355f29d257334e3a281181c873ee9f03baef"
  git_remote: "https://github.com/openpipelines-bio/openpipeline"
