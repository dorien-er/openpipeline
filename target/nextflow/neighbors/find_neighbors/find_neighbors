#!/usr/bin/env bash

#################################
#    find_neighbors 0.3.0rc2    #
#################################

# This wrapper script is auto-generated by viash 0.5.10.1 and is thus a
# derivative work thereof. This software comes with ABSOLUTELY NO WARRANTY from
# Data Intuitive.  The component may contain files which fall under a different
# license. The authors of this component should specify the license in the
# header of such files, or include a separate license file detailing the
# licenses of all included files.
#
# Component authors:
# * Dries De Maeyer <ddemaeyer@gmail.com> (maintainer) {account: ddemaey1}
# * Robrecht Cannoodt <rcannood@gmail.com> (contributor) {github: rcannood, orcid: 0000-0003-3641-729X}

set -e

if [ -z "$VIASH_TEMP" ]; then
  VIASH_TEMP=/tmp
fi

# define helper functions
# ViashQuote: put quotes around non flag values
# $1     : unquoted string
# return : possibly quoted string
# examples:
#   ViashQuote --foo      # returns --foo
#   ViashQuote bar        # returns 'bar'
#   Viashquote --foo=bar  # returns --foo='bar'
function ViashQuote {
  if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
    echo "$1" | sed "s#=\(.*\)#='\1'#"
  elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
    echo "$1"
  else
    echo "'$1'"
  fi
}
# ViashRemoveFlags: Remove leading flag
# $1     : string with a possible leading flag
# return : string without possible leading flag
# examples:
#   ViashRemoveFlags --foo=bar  # returns bar
function ViashRemoveFlags {
  echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
}
# ViashSourceDir: return the path of a bash file, following symlinks
# usage   : ViashSourceDir ${BASH_SOURCE[0]}
# $1      : Should always be set to ${BASH_SOURCE[0]}
# returns : The absolute path of the bash file
function ViashSourceDir {
  SOURCE="$1"
  while [ -h "$SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
}
# see https://en.wikipedia.org/wiki/Syslog#Severity_level
VIASH_LOGCODE_EMERGENCY=0
VIASH_LOGCODE_ALERT=1
VIASH_LOGCODE_CRITICAL=2
VIASH_LOGCODE_ERROR=3
VIASH_LOGCODE_WARNING=4
VIASH_LOGCODE_NOTICE=5
VIASH_LOGCODE_INFO=6
VIASH_LOGCODE_DEBUG=7
VIASH_VERBOSITY=$VIASH_LOGCODE_NOTICE

# ViashLog: Log events depending on the verbosity level
# usage: ViashLog 1 alert Oh no something went wrong!
# $1: required verbosity level
# $2: display tag
# $3+: messages to display
# stdout: Your input, prepended by '[$2] '.
function ViashLog {
  local required_level="$1"
  local display_tag="$2"
  shift 2
  if [ $VIASH_VERBOSITY -ge $required_level ]; then
    echo "[$display_tag]" "$@"
  fi
}

# ViashEmergency: log events when the system is unstable
# usage: ViashEmergency Oh no something went wrong.
# stdout: Your input, prepended by '[emergency] '.
function ViashEmergency {
  ViashLog $VIASH_LOGCODE_EMERGENCY emergency $@
}

# ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
# usage: ViashAlert Oh no something went wrong.
# stdout: Your input, prepended by '[alert] '.
function ViashAlert {
  ViashLog $VIASH_LOGCODE_ALERT alert $@
}

# ViashCritical: log events when a critical condition occurs
# usage: ViashCritical Oh no something went wrong.
# stdout: Your input, prepended by '[critical] '.
function ViashCritical {
  ViashLog $VIASH_LOGCODE_CRITICAL critical $@
}

# ViashError: log events when an error condition occurs
# usage: ViashError Oh no something went wrong.
# stdout: Your input, prepended by '[error] '.
function ViashError {
  ViashLog $VIASH_LOGCODE_ERROR error $@
}

# ViashWarning: log potentially abnormal events
# usage: ViashWarning Something may have gone wrong.
# stdout: Your input, prepended by '[warning] '.
function ViashWarning {
  ViashLog $VIASH_LOGCODE_WARNING warning $@
}

# ViashNotice: log significant but normal events
# usage: ViashNotice This just happened.
# stdout: Your input, prepended by '[notice] '.
function ViashNotice {
  ViashLog $VIASH_LOGCODE_NOTICE notice $@
}

# ViashInfo: log normal events
# usage: ViashInfo This just happened.
# stdout: Your input, prepended by '[info] '.
function ViashInfo {
  ViashLog $VIASH_LOGCODE_INFO info $@
}

# ViashDebug: log all events, for debugging purposes
# usage: ViashDebug This just happened.
# stdout: Your input, prepended by '[debug] '.
function ViashDebug {
  ViashLog $VIASH_LOGCODE_DEBUG debug $@
}

# find source folder of this component
VIASH_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`

# define meta fields
VIASH_META_FUNCTIONALITY_NAME="find_neighbors"


# ViashHelp: Display helpful explanation about this executable
function ViashHelp {
  echo "find_neighbors 0.3.0rc2"
  echo "Compute a neighborhood graph of observations [McInnes18]."
  echo ""
  echo "The neighbor search efficiency of this heavily relies on UMAP [McInnes18], which also provides a method for estimating connectivities of data points - the connectivity of the manifold (method=='umap'). If method=='gauss', connectivities are computed according to [Coifman05], in the adaption of [Haghverdi16]."
  echo
  echo "Options:"

  echo "   -i, --input"
  echo "        type: file, required parameter"
  echo "        example: input.h5mu"
  echo "        Input h5mu file"
  echo ""


  echo "   --modality"
  echo "        type: string, multiple values allowed"
  echo "        default: rna"
  echo ""


  echo "   -o, --output"
  echo "        type: file, output"
  echo "        example: output.h5mu"
  echo "        Output h5mu file containing the found neighbors."
  echo ""


  echo "   --obsp_name_prefix"
  echo "        type: string"
  echo "        example: foo"
  echo "        An optional prefix for the obsp slot. If not specified, the neighbors data is stored in .uns['neighbors'], distances and connectivities are stored in .obsp['distances'] and .obsp['connectivities'] respectively. If specified, the neighbors data is added to .uns[key_added], distances are stored in .obsp[key_added+'_distances'] and connectivities in .obsp[key_added+'_connectivities']."
  echo ""


  echo "   --metric"
  echo "        type: string"
  echo "        default: euclidean"
  echo "        The distance metric to be used in the generation of the nearest neighborhood network."
  echo ""


  echo "   --num_neighbors"
  echo "        type: integer"
  echo "        default: 15"
  echo "        The size of local neighborhood (in terms of number of neighboring data points) used for manifold approximation. Larger values result in more global views of the manifold, while smaller values result in more local data being preserved. In general values should be in the range 2 to 100. If knn is True, number of nearest neighbors to be searched. If knn is False, a Gaussian kernel width is set to the distance of the n_neighbors neighbor."
  echo ""

}

# initialise array
VIASH_POSITIONAL_ARGS=''
VIASH_MODE='run'

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            ViashHelp
            exit
            ;;
        ---v|---verbose)
            let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
            shift 1
            ;;
        ---verbosity)
            VIASH_VERBOSITY="$2"
            shift 2
            ;;
        ---verbosity=*)
            VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
            shift 1
            ;;
        --version)
            echo "find_neighbors 0.3.0rc2"
            exit
            ;;
        --input)
            VIASH_PAR_INPUT="$2"
            shift 2
            ;;
        --input=*)
            VIASH_PAR_INPUT=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        -i)
            VIASH_PAR_INPUT="$2"
            shift 2
            ;;
        --modality)
            if [ -z "$VIASH_PAR_MODALITY" ]; then
              VIASH_PAR_MODALITY="$2"
            else
              VIASH_PAR_MODALITY="$VIASH_PAR_MODALITY:""$2"
            fi
            shift 2
            ;;
        --modality=*)
            if [ -z "$VIASH_PAR_MODALITY" ]; then
              VIASH_PAR_MODALITY=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_MODALITY="$VIASH_PAR_MODALITY:"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        --output)
            VIASH_PAR_OUTPUT="$2"
            shift 2
            ;;
        --output=*)
            VIASH_PAR_OUTPUT=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        -o)
            VIASH_PAR_OUTPUT="$2"
            shift 2
            ;;
        --obsp_name_prefix)
            VIASH_PAR_OBSP_NAME_PREFIX="$2"
            shift 2
            ;;
        --obsp_name_prefix=*)
            VIASH_PAR_OBSP_NAME_PREFIX=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --metric)
            VIASH_PAR_METRIC="$2"
            shift 2
            ;;
        --metric=*)
            VIASH_PAR_METRIC=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --num_neighbors)
            VIASH_PAR_NUM_NEIGHBORS="$2"
            shift 2
            ;;
        --num_neighbors=*)
            VIASH_PAR_NUM_NEIGHBORS=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        *)  # positional arg or unknown option
            # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
            VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
            shift # past argument
            ;;
    esac
done

# parse positional parameters
eval set -- $VIASH_POSITIONAL_ARGS




# check whether required parameters exist
if [ -z "$VIASH_PAR_INPUT" ]; then
  ViashError '--input' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z "$VIASH_PAR_MODALITY" ]; then
  VIASH_PAR_MODALITY="rna"
fi
if [ -z "$VIASH_PAR_METRIC" ]; then
  VIASH_PAR_METRIC="euclidean"
fi
if [ -z "$VIASH_PAR_NUM_NEIGHBORS" ]; then
  VIASH_PAR_NUM_NEIGHBORS="15"
fi


cat << VIASHEOF | bash
set -e
tempscript=\$(mktemp "$VIASH_TEMP/viash-run-find_neighbors-XXXXXX")
function clean_up {
  rm "\$tempscript"
}
function interrupt {
  echo -e "\nCTRL-C Pressed..."
  exit 1
}
trap clean_up EXIT
trap interrupt INT SIGINT
cat > "\$tempscript" << 'VIASHMAIN'
import muon as mu
import scanpy as sc

## VIASH START
# The following code has been auto-generated by Viash.
par = {
  'input': $( if [ ! -z ${VIASH_PAR_INPUT+x} ]; then echo "'$VIASH_PAR_INPUT'"; else echo None; fi ),
  'modality': $( if [ ! -z ${VIASH_PAR_MODALITY+x} ]; then echo "'$VIASH_PAR_MODALITY'.split(':')"; else echo None; fi ),
  'output': $( if [ ! -z ${VIASH_PAR_OUTPUT+x} ]; then echo "'$VIASH_PAR_OUTPUT'"; else echo None; fi ),
  'obsp_name_prefix': $( if [ ! -z ${VIASH_PAR_OBSP_NAME_PREFIX+x} ]; then echo "'$VIASH_PAR_OBSP_NAME_PREFIX'"; else echo None; fi ),
  'metric': $( if [ ! -z ${VIASH_PAR_METRIC+x} ]; then echo "'$VIASH_PAR_METRIC'"; else echo None; fi ),
  'num_neighbors': $( if [ ! -z ${VIASH_PAR_NUM_NEIGHBORS+x} ]; then echo "int('$VIASH_PAR_NUM_NEIGHBORS')"; else echo None; fi )
}
meta = {
  'functionality_name': '$VIASH_META_FUNCTIONALITY_NAME',
  'resources_dir': '$VIASH_RESOURCES_DIR'
}

resources_dir = '$VIASH_RESOURCES_DIR'

## VIASH END

print("Reading input mudata")
mdata = mu.read_h5mu(par["input"])
mdata.var_names_make_unique()

for mod in par["modality"]:
    print(f"Computing a neighborhood graph on modality {mod}")
    sc.pp.neighbors(
        mdata.mod[mod],
        n_neighbors=par["num_neighbors"], 
        metric=par["metric"],
        key_added=par["obsp_name_prefix"]
    )

print("Writing to file")
mdata.write(filename=par["output"])
VIASHMAIN
python "\$tempscript" &
wait "\$!"

VIASHEOF
