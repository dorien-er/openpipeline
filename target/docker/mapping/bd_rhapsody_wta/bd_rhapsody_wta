#!/usr/bin/env bash

# bd_rhapsody_wta main_build
# 
# This wrapper script is auto-generated by viash 0.5.14 and is thus a derivative
# work thereof. This software comes with ABSOLUTELY NO WARRANTY from Data
# Intuitive.
# 
# The component may contain files which fall under a different license. The
# authors of this component should specify the license in the header of such
# files, or include a separate license file detailing the licenses of all included
# files.
# 
# Component authors:
#  * Robrecht Cannoodt <rcannood@gmail.com> (maintainer) {github: rcannood, orcid:
# 0000-0003-3641-729X}

set -e

if [ -z "$VIASH_TEMP" ]; then
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TEMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMP}
  VIASH_TEMP=${VIASH_TEMP:-$TMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$TMP}
  VIASH_TEMP=${VIASH_TEMP:-$TEMPDIR}
  VIASH_TEMP=${VIASH_TEMP:-$TEMP}
  VIASH_TEMP=${VIASH_TEMP:-/tmp}
fi

# define helper functions
# ViashQuote: put quotes around non flag values
# $1     : unquoted string
# return : possibly quoted string
# examples:
#   ViashQuote --foo      # returns --foo
#   ViashQuote bar        # returns 'bar'
#   Viashquote --foo=bar  # returns --foo='bar'
function ViashQuote {
  if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
    echo "$1" | sed "s#=\(.*\)#='\1'#"
  elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
    echo "$1"
  else
    echo "'$1'"
  fi
}
# ViashRemoveFlags: Remove leading flag
# $1     : string with a possible leading flag
# return : string without possible leading flag
# examples:
#   ViashRemoveFlags --foo=bar  # returns bar
function ViashRemoveFlags {
  echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
}
# ViashSourceDir: return the path of a bash file, following symlinks
# usage   : ViashSourceDir ${BASH_SOURCE[0]}
# $1      : Should always be set to ${BASH_SOURCE[0]}
# returns : The absolute path of the bash file
function ViashSourceDir {
  SOURCE="$1"
  while [ -h "$SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
}
# see https://en.wikipedia.org/wiki/Syslog#Severity_level
VIASH_LOGCODE_EMERGENCY=0
VIASH_LOGCODE_ALERT=1
VIASH_LOGCODE_CRITICAL=2
VIASH_LOGCODE_ERROR=3
VIASH_LOGCODE_WARNING=4
VIASH_LOGCODE_NOTICE=5
VIASH_LOGCODE_INFO=6
VIASH_LOGCODE_DEBUG=7
VIASH_VERBOSITY=$VIASH_LOGCODE_NOTICE

# ViashLog: Log events depending on the verbosity level
# usage: ViashLog 1 alert Oh no something went wrong!
# $1: required verbosity level
# $2: display tag
# $3+: messages to display
# stdout: Your input, prepended by '[$2] '.
function ViashLog {
  local required_level="$1"
  local display_tag="$2"
  shift 2
  if [ $VIASH_VERBOSITY -ge $required_level ]; then
    echo "[$display_tag]" "$@"
  fi
}

# ViashEmergency: log events when the system is unstable
# usage: ViashEmergency Oh no something went wrong.
# stdout: Your input, prepended by '[emergency] '.
function ViashEmergency {
  ViashLog $VIASH_LOGCODE_EMERGENCY emergency $@
}

# ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
# usage: ViashAlert Oh no something went wrong.
# stdout: Your input, prepended by '[alert] '.
function ViashAlert {
  ViashLog $VIASH_LOGCODE_ALERT alert $@
}

# ViashCritical: log events when a critical condition occurs
# usage: ViashCritical Oh no something went wrong.
# stdout: Your input, prepended by '[critical] '.
function ViashCritical {
  ViashLog $VIASH_LOGCODE_CRITICAL critical $@
}

# ViashError: log events when an error condition occurs
# usage: ViashError Oh no something went wrong.
# stdout: Your input, prepended by '[error] '.
function ViashError {
  ViashLog $VIASH_LOGCODE_ERROR error $@
}

# ViashWarning: log potentially abnormal events
# usage: ViashWarning Something may have gone wrong.
# stdout: Your input, prepended by '[warning] '.
function ViashWarning {
  ViashLog $VIASH_LOGCODE_WARNING warning $@
}

# ViashNotice: log significant but normal events
# usage: ViashNotice This just happened.
# stdout: Your input, prepended by '[notice] '.
function ViashNotice {
  ViashLog $VIASH_LOGCODE_NOTICE notice $@
}

# ViashInfo: log normal events
# usage: ViashInfo This just happened.
# stdout: Your input, prepended by '[info] '.
function ViashInfo {
  ViashLog $VIASH_LOGCODE_INFO info $@
}

# ViashDebug: log all events, for debugging purposes
# usage: ViashDebug This just happened.
# stdout: Your input, prepended by '[debug] '.
function ViashDebug {
  ViashLog $VIASH_LOGCODE_DEBUG debug $@
}

# find source folder of this component
VIASH_META_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`

# backwards compatibility
VIASH_RESOURCES_DIR="$VIASH_META_RESOURCES_DIR"

# define meta fields
VIASH_META_FUNCTIONALITY_NAME="bd_rhapsody_wta"
VIASH_META_EXECUTABLE="$VIASH_META_RESOURCES_DIR/$VIASH_META_FUNCTIONALITY_NAME"


# ViashHelp: Display helpful explanation about this executable
function ViashHelp {
  echo "bd_rhapsody_wta main_build"
  echo ""
  echo "A wrapper for the BD Rhapsody Analysis CWL v1.9.1 pipeline."
  echo ""
  echo "The CWL pipeline file is obtained by cloning"
  echo "'https://bitbucket.org/CRSwDev/cwl/src/master/' and removing all objects with"
  echo "class 'DockerRequirement' from the YML."
  echo ""
  echo "The reference_genome and transcriptome_annotation files can be downloaded from"
  echo "these locations:"
  echo "  - Human:"
  echo "http://bd-rhapsody-public.s3-website-us-east-1.amazonaws.com/Rhapsody-WTA/GRCh38-PhiX-gencodev29/"
  echo "  - Mouse:"
  echo "http://bd-rhapsody-public.s3-website-us-east-1.amazonaws.com/Rhapsody-WTA/GRCm38-PhiX-gencodevM19/"
  echo ""
  echo "Options:"
  echo "    -i, --input"
  echo "        type: file, required parameter, multiple values allowed"
  echo "        example: input.fastq.gz"
  echo "        Path to your read files in the FASTQ.GZ format. You may specify as many"
  echo "R1/R2 read pairs as you want."
  echo ""
  echo "    -r, --reference_genome"
  echo "        type: file, required parameter"
  echo "        example: reference_genome.tar.gz"
  echo "        Path to STAR index as a tar.gz file."
  echo ""
  echo "    -t, --transcriptome_annotation"
  echo "        type: file, required parameter"
  echo "        example: transcriptome.gtf"
  echo "        Path to GTF annotation file."
  echo ""
  echo "    -a, --abseq_reference"
  echo "        type: file, multiple values allowed"
  echo "        Path to the AbSeq reference file in FASTA format. Only needed if BD"
  echo "AbSeq Ab-Oligos are used."
  echo ""
  echo "    -s, --supplemental_reference"
  echo "        type: file, multiple values allowed"
  echo "        Path to the supplemental reference file in FASTA format. Only needed if"
  echo "there are additional transgene sequences used in the experiment."
  echo ""
  echo "    -o, --output"
  echo "        type: file, required parameter, output"
  echo "        example: output_dir"
  echo "        Output folder. Output still needs to be processed further."
  echo ""
  echo "    --exact_cell_count"
  echo "        type: integer"
  echo "        example: 10000"
  echo "        Exact cell count - Set a specific number (>=1) of cells as putative,"
  echo "based on those with the highest error-corrected read count"
  echo ""
  echo "    --disable_putative_calling"
  echo "        type: boolean_true"
  echo "        Disable Refined Putative Cell Calling - Determine putative cells using"
  echo "only the basic algorithm (minimum second derivative along the cumulative reads"
  echo "curve). The refined algorithm attempts to remove false positives and recover"
  echo "false negatives, but may not be ideal for certain complex mixtures of cell"
  echo "types. Does not apply if Exact Cell Count is set."
  echo ""
  echo "    --subsample"
  echo "        type: double"
  echo "        example: 0.01"
  echo "        A number >1 or fraction (0 < n < 1) to indicate the number or percentage"
  echo "of reads to subsample."
  echo ""
  echo "    --subsample_seed"
  echo "        type: integer"
  echo "        example: 3445"
  echo "        A seed for replicating a previous subsampled run."
  echo ""
  echo "    --sample_tags_version"
  echo "        type: string"
  echo "        example: human"
  echo "        choices: [ human, hs, mouse, mm ]"
  echo "        Specify if multiplexed run."
  echo ""
  echo "    --tag_names"
  echo "        type: string, multiple values allowed"
  echo "        example: 4-mySample:9-myOtherSample:6-alsoThisSample"
  echo "        Tag_Names (optional) - Specify the tag number followed by '-' and the"
  echo "desired sample name to appear in Sample_Tag_Metrics.csv"
  echo "        Do not use the special characters: &, (), [], {},  <>, ?, |"
  echo ""
  echo "    --parallel"
  echo "        type: boolean"
  echo "        default: true"
  echo "        Run jobs in parallel."
  echo ""
  echo "    --timestamps"
  echo "        type: boolean_true"
  echo "        Add timestamps to the errors, warnings, and notifications."
  echo ""
  echo "    --override_min_ram"
  echo "        type: integer"
  echo "        example: 2"
  echo "        Override the minimum RAM requirements specified in the CWL (in GB)."
  echo ""
  echo "    --override_min_cores"
  echo "        type: integer"
  echo "        example: 2"
  echo "        Override the minimum cores requirements specified in the CWL."
  echo ""
  echo "    --dryrun"
  echo "        type: boolean_true"
  echo "        If true, the output directory will only contain the CWL input files, but"
  echo "the pipeline itself will not be executed."
}
######## Helper functions for setting up Docker images for viash ########
# expects: ViashDockerBuild

# ViashDockerInstallationCheck: check whether Docker is installed correctly
#
# examples:
#   ViashDockerInstallationCheck
function ViashDockerInstallationCheck {
  ViashDebug "Checking whether Docker is installed"
  if [ ! command -v docker &> /dev/null ]; then
    ViashCritical "Docker doesn't seem to be installed. See 'https://docs.docker.com/get-docker/' for instructions."
    exit 1
  fi

  ViashDebug "Checking whether the Docker daemon is running"
  save=$-; set +e
  docker_version=$(docker version --format '{{.Client.APIVersion}}' 2> /dev/null)
  out=$?
  [[ $save =~ e ]] && set -e
  if [ $out -ne 0 ]; then
    ViashCritical "Docker daemon does not seem to be running. Try one of the following:"
    ViashCritical "- Try running 'dockerd' in the command line"
    ViashCritical "- See https://docs.docker.com/config/daemon/"
    exit 1
  fi
}

# ViashDockerRemoteTagCheck: check whether a Docker image is available 
# on a remote. Assumes `docker login` has been performed, if relevant.
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerRemoteTagCheck python:latest
#   echo $?                                     # returns '0'
#   ViashDockerRemoteTagCheck sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerRemoteTagCheck {
  docker manifest inspect $1 > /dev/null 2> /dev/null
}

# ViashDockerLocalTagCheck: check whether a Docker image is available locally
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   docker pull python:latest
#   ViashDockerLocalTagCheck python:latest
#   echo $?                                     # returns '0'
#   ViashDockerLocalTagCheck sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerLocalTagCheck {
  [ -n "$(docker images -q $1)" ]
}

# ViashDockerPull: pull a Docker image
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerPull python:latest
#   echo $?                                     # returns '0'
#   ViashDockerPull sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerPull {
  ViashNotice "Checking if Docker image is available at '$1'"
  if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
    docker pull $1 && return 0 || return 1
  else
    save=$-; set +e
    docker pull $1 2> /dev/null > /dev/null
    out=$?
    [[ $save =~ e ]] && set -e
    if [ $out -ne 0 ]; then
      ViashWarning "Could not pull from '$1'. Docker image doesn't exist or is not accessible."
    fi
    return $out
  fi
}

# ViashDockerPush: push a Docker image
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# exit code $?        : whether or not the image was found
# examples:
#   ViashDockerPush python:latest
#   echo $?                                     # returns '0'
#   ViashDockerPush sdaizudceahifu
#   echo $?                                     # returns '1'
function ViashDockerPush {
  ViashNotice "Pushing image to '$1'"
  save=$-; set +e
  if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
    docker push $1
    out=$?
  else
    docker push $1 2> /dev/null > /dev/null
    out=$?
  fi
  [[ $save =~ e ]] && set -e
  if [ $out -eq 0 ]; then
    ViashNotice "Container '$VSHD_ID' push succeeded."
  else
    ViashError "Container '$VSHD_ID' push errored. You might not be logged in or have the necessary permissions."
  fi
  return $out
}

# ViashDockerPullElseBuild: pull a Docker image, else build it
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
# examples:
#   ViashDockerPullElseBuild mynewcomponent
function ViashDockerPullElseBuild {
  save=$-; set +e
  ViashDockerPull $1
  out=$?
  [[ $save =~ e ]] && set -e
  if [ $out -ne 0 ]; then
    ViashDockerBuild $@
  fi
}

# ViashDockerSetup: create a Docker image, according to specified docker setup strategy
#
# $1                  : image identifier with format `[registry/]image[:tag]`
# $2                  : docker setup strategy, see DockerSetupStrategy.scala
# ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
# examples:
#   ViashDockerSetup mynewcomponent alwaysbuild
function ViashDockerSetup {
  VSHD_ID="$1"
  VSHD_STRAT="$2"
  if [ "$VSHD_STRAT" == "alwaysbuild" -o "$VSHD_STRAT" == "build" -o "$VSHD_STRAT" == "b" ]; then
    ViashDockerBuild $VSHD_ID --no-cache
  elif [ "$VSHD_STRAT" == "alwayspull" -o "$VSHD_STRAT" == "pull" -o "$VSHD_STRAT" == "p" ]; then
    ViashDockerPull $VSHD_ID
  elif [ "$VSHD_STRAT" == "alwayspullelsebuild" -o "$VSHD_STRAT" == "pullelsebuild" ]; then
    ViashDockerPullElseBuild $VSHD_ID --no-cache
  elif [ "$VSHD_STRAT" == "alwayspullelsecachedbuild" -o "$VSHD_STRAT" == "pullelsecachedbuild" ]; then
    ViashDockerPullElseBuild $VSHD_ID
  elif [ "$VSHD_STRAT" == "alwayscachedbuild" -o "$VSHD_STRAT" == "cachedbuild" -o "$VSHD_STRAT" == "cb" ]; then
    ViashDockerBuild $VSHD_ID
  elif [[ "$VSHD_STRAT" =~ ^ifneedbe ]]; then
    save=$-; set +e
    ViashDockerLocalTagCheck $VSHD_ID
    outCheck=$?
    [[ $save =~ e ]] && set -e
    if [ $outCheck -eq 0 ]; then
      ViashInfo "Image $VSHD_ID already exists"
    elif [ "$VSHD_STRAT" == "ifneedbebuild" ]; then
      ViashDockerBuild $VSHD_ID --no-cache
    elif [ "$VSHD_STRAT" == "ifneedbecachedbuild" ]; then
      ViashDockerBuild $VSHD_ID
    elif [ "$VSHD_STRAT" == "ifneedbepull" ]; then
      ViashDockerPull $VSHD_ID
    elif [ "$VSHD_STRAT" == "ifneedbepullelsebuild" ]; then
      ViashDockerPullElseBuild $VSHD_ID --no-cache
    elif [ "$VSHD_STRAT" == "ifneedbepullelsecachedbuild" ]; then
      ViashDockerPullElseBuild $VSHD_ID
    else
      ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
      exit 1
    fi
  elif [ "$VSHD_STRAT" == "push" -o "$VSHD_STRAT" == "forcepush" -o "$VSHD_STRAT" == "alwayspush" ]; then
    ViashDockerPush "$VSHD_ID"
  elif [ "$VSHD_STRAT" == "pushifnotpresent" -o "$VSHD_STRAT" == "gentlepush" -o "$VSHD_STRAT" == "maybepush" ]; then
    save=$-; set +e
    ViashDockerRemoteTagCheck $VSHD_ID
    outCheck=$?
    [[ $save =~ e ]] && set -e
    if [ $outCheck -eq 0 ]; then
      ViashNotice "Container '$VSHD_ID' exists, doing nothing."
    else
      ViashNotice "Container '$VSHD_ID' does not yet exist."
      ViashDockerPush "$VSHD_ID"
    fi
  elif [ "$VSHD_STRAT" == "donothing" -o "$VSHD_STRAT" == "meh" ]; then
    ViashNotice "Skipping setup."
  else
    ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
    exit 1
  fi
}


######## End of helper functions for setting up Docker images for viash ########

# ViashDockerFile: print the dockerfile to stdout
# return : dockerfile required to run this component
# examples:
#   ViashDockerFile
function ViashDockerfile {
  cat << 'VIASHDOCKER'
FROM bdgenomics/rhapsody:1.9.1

RUN apt-get --allow-releaseinfo-change update && apt upgrade -y && conda install -y -c bioconda picard=2.27.3 ca-certificates=2022.6.15
RUN apt-get update && \
  DEBIAN_FRONTEND=noninteractive apt-get install -y procps nodejs && \
  rm -rf /var/lib/apt/lists/*

RUN pip install --upgrade pip && \
  pip install --upgrade --no-cache-dir "cwlref-runner" "cwl-runner" "ruamel.yaml"

LABEL org.opencontainers.image.authors="Robrecht Cannoodt <rcannood@gmail.com> (maintainer) {github: rcannood, orcid: 0000-0003-3641-729X}"
LABEL org.opencontainers.image.description="Companion container for running component mapping bd_rhapsody_wta"
LABEL org.opencontainers.image.created="2022-07-04T08:23:40Z"
LABEL org.opencontainers.image.source="https://github.com/openpipelines-bio/openpipeline"
LABEL org.opencontainers.image.revision="2826a5524df4b00ed42d1f643cb421ea2f75292f"
LABEL org.opencontainers.image.version="main_build"
VIASHDOCKER
}

# ViashDockerBuild: build a docker container
# $1              : image identifier with format `[registry/]image[:tag]`
# exit code $?    : whether or not the image was built
function ViashDockerBuild {
  # create temporary directory to store dockerfile & optional resources in
  tmpdir=$(mktemp -d "$VIASH_TEMP/viashsetupdocker-bd_rhapsody_wta-XXXXXX")
  function clean_up {
    rm -rf "$tmpdir"
  }
  trap clean_up EXIT

  # store dockerfile and resources
  ViashDockerfile > $tmpdir/Dockerfile
  cp -r $VIASH_META_RESOURCES_DIR/* $tmpdir

  # Build the container
  ViashNotice "Building container '$1' with Dockerfile"
  ViashInfo "Running 'docker build -t $@ $tmpdir'"
  save=$-; set +e
  if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
    docker build -t $@ $tmpdir
  else
    docker build -t $@ $tmpdir &> $tmpdir/docker_build.log
  fi
  out=$?
  [[ $save =~ e ]] && set -e
  if [ $out -ne 0 ]; then
    ViashError "Error occurred while building container '$1'"
    if [ $VIASH_VERBOSITY -lt $VIASH_LOGCODE_INFO ]; then
      ViashError "Transcript: --------------------------------"
      cat "$tmpdir/docker_build.log"
      ViashError "End of transcript --------------------------"
    fi
    exit 1
  fi
}
# ViashAbsolutePath: generate absolute path from relative path
# borrowed from https://stackoverflow.com/a/21951256
# $1     : relative filename
# return : absolute path
# examples:
#   ViashAbsolutePath some_file.txt   # returns /path/to/some_file.txt
#   ViashAbsolutePath /foo/bar/..     # returns /foo
function ViashAbsolutePath {
  local thePath
  if [[ ! "$1" =~ ^/ ]]; then
    thePath="$PWD/$1"
  else
    thePath="$1"
  fi
  echo "$thePath" | (
    IFS=/
    read -a parr
    declare -a outp
    for i in "${parr[@]}"; do
      case "$i" in
      ''|.) continue ;;
      ..)
        len=${#outp[@]}
        if ((len==0)); then
          continue
        else
          unset outp[$((len-1))]
        fi
        ;;
      *)
        len=${#outp[@]}
        outp[$len]="$i"
      ;;
      esac
    done
    echo /"${outp[*]}"
  )
}
# ViashAutodetectMount: auto configuring docker mounts from parameters
# $1                  : The parameter value
# returns             : New parameter
# $VIASH_EXTRA_MOUNTS : Added another parameter to be passed to docker
# examples:
#   ViashAutodetectMount /path/to/bar      # returns '/viash_automount/path/to/bar'
#   ViashAutodetectMountArg /path/to/bar   # returns '-v /path/to:/viash_automount/path/to'
function ViashAutodetectMount {
  abs_path=$(ViashAbsolutePath "$1")
  if [ -d "$abs_path" ]; then
    mount_source="$abs_path"
    base_name=""
  else
    mount_source=`dirname "$abs_path"`
    base_name=`basename "$abs_path"`
  fi
  mount_target="/viash_automount$mount_source"
  echo "$mount_target/$base_name"
}
function ViashAutodetectMountArg {
  abs_path=$(ViashAbsolutePath "$1")
  if [ -d "$abs_path" ]; then
    mount_source="$abs_path"
    base_name=""
  else
    mount_source=`dirname "$abs_path"`
    base_name=`basename "$abs_path"`
  fi
  mount_target="/viash_automount$mount_source"
  echo "-v \"$mount_source:$mount_target\""
}
# ViashExtractFlags: Retain leading flag
# $1     : string with a possible leading flag
# return : leading flag
# examples:
#   ViashExtractFlags --foo=bar  # returns --foo
function ViashExtractFlags {
  echo $1 | sed 's/=.*//'
}
# initialise variables
VIASH_EXTRA_MOUNTS=''

# initialise array
VIASH_POSITIONAL_ARGS=''
VIASH_MODE='run'

while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            ViashHelp
            exit
            ;;
        ---v|---verbose)
            let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
            shift 1
            ;;
        ---verbosity)
            VIASH_VERBOSITY="$2"
            shift 2
            ;;
        ---verbosity=*)
            VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
            shift 1
            ;;
        --version)
            echo "bd_rhapsody_wta main_build"
            exit
            ;;
        --input)
            if [ -z "$VIASH_PAR_INPUT" ]; then
              VIASH_PAR_INPUT="$2"
            else
              VIASH_PAR_INPUT="$VIASH_PAR_INPUT:""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --input. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --input=*)
            if [ -z "$VIASH_PAR_INPUT" ]; then
              VIASH_PAR_INPUT=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_INPUT="$VIASH_PAR_INPUT:"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        -i)
            if [ -z "$VIASH_PAR_INPUT" ]; then
              VIASH_PAR_INPUT="$2"
            else
              VIASH_PAR_INPUT="$VIASH_PAR_INPUT:""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -i. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --reference_genome)
            VIASH_PAR_REFERENCE_GENOME="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --reference_genome. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --reference_genome=*)
            VIASH_PAR_REFERENCE_GENOME=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        -r)
            VIASH_PAR_REFERENCE_GENOME="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -r. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --transcriptome_annotation)
            VIASH_PAR_TRANSCRIPTOME_ANNOTATION="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --transcriptome_annotation. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --transcriptome_annotation=*)
            VIASH_PAR_TRANSCRIPTOME_ANNOTATION=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        -t)
            VIASH_PAR_TRANSCRIPTOME_ANNOTATION="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -t. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --abseq_reference)
            if [ -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
              VIASH_PAR_ABSEQ_REFERENCE="$2"
            else
              VIASH_PAR_ABSEQ_REFERENCE="$VIASH_PAR_ABSEQ_REFERENCE:""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --abseq_reference. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --abseq_reference=*)
            if [ -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
              VIASH_PAR_ABSEQ_REFERENCE=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_ABSEQ_REFERENCE="$VIASH_PAR_ABSEQ_REFERENCE:"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        -a)
            if [ -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
              VIASH_PAR_ABSEQ_REFERENCE="$2"
            else
              VIASH_PAR_ABSEQ_REFERENCE="$VIASH_PAR_ABSEQ_REFERENCE:""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -a. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --supplemental_reference)
            if [ -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$2"
            else
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$VIASH_PAR_SUPPLEMENTAL_REFERENCE:""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --supplemental_reference. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --supplemental_reference=*)
            if [ -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
              VIASH_PAR_SUPPLEMENTAL_REFERENCE=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$VIASH_PAR_SUPPLEMENTAL_REFERENCE:"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        -s)
            if [ -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$2"
            else
              VIASH_PAR_SUPPLEMENTAL_REFERENCE="$VIASH_PAR_SUPPLEMENTAL_REFERENCE:""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -s. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --output)
            VIASH_PAR_OUTPUT="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --output. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --output=*)
            VIASH_PAR_OUTPUT=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        -o)
            VIASH_PAR_OUTPUT="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to -o. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --exact_cell_count)
            VIASH_PAR_EXACT_CELL_COUNT="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --exact_cell_count. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --exact_cell_count=*)
            VIASH_PAR_EXACT_CELL_COUNT=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --disable_putative_calling)
            VIASH_PAR_DISABLE_PUTATIVE_CALLING=true
            shift 1
            ;;
        --subsample)
            VIASH_PAR_SUBSAMPLE="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --subsample. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --subsample=*)
            VIASH_PAR_SUBSAMPLE=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --subsample_seed)
            VIASH_PAR_SUBSAMPLE_SEED="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --subsample_seed. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --subsample_seed=*)
            VIASH_PAR_SUBSAMPLE_SEED=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --sample_tags_version)
            VIASH_PAR_SAMPLE_TAGS_VERSION="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --sample_tags_version. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --sample_tags_version=*)
            VIASH_PAR_SAMPLE_TAGS_VERSION=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --tag_names)
            if [ -z "$VIASH_PAR_TAG_NAMES" ]; then
              VIASH_PAR_TAG_NAMES="$2"
            else
              VIASH_PAR_TAG_NAMES="$VIASH_PAR_TAG_NAMES:""$2"
            fi
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --tag_names. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --tag_names=*)
            if [ -z "$VIASH_PAR_TAG_NAMES" ]; then
              VIASH_PAR_TAG_NAMES=$(ViashRemoveFlags "$1")
            else
              VIASH_PAR_TAG_NAMES="$VIASH_PAR_TAG_NAMES:"$(ViashRemoveFlags "$1")
            fi
            shift 1
            ;;
        --parallel)
            VIASH_PAR_PARALLEL="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --parallel. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --parallel=*)
            VIASH_PAR_PARALLEL=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --timestamps)
            VIASH_PAR_TIMESTAMPS=true
            shift 1
            ;;
        --override_min_ram)
            VIASH_PAR_OVERRIDE_MIN_RAM="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --override_min_ram. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --override_min_ram=*)
            VIASH_PAR_OVERRIDE_MIN_RAM=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --override_min_cores)
            VIASH_PAR_OVERRIDE_MIN_CORES="$2"
            [ $# -lt 2 ] && ViashError Not enough arguments passed to --override_min_cores. Use "--help" to get more information on the parameters. && exit 1
            shift 2
            ;;
        --override_min_cores=*)
            VIASH_PAR_OVERRIDE_MIN_CORES=$(ViashRemoveFlags "$1")
            shift 1
            ;;
        --dryrun)
            VIASH_PAR_DRYRUN=true
            shift 1
            ;;
        ---setup)
            VIASH_MODE='docker_setup'
            VIASH_DOCKER_SETUP_STRATEGY="$2"
            shift 1
            ;;
        ---setup=*)
            VIASH_MODE='docker_setup'
            VIASH_DOCKER_SETUP_STRATEGY="$(ViashRemoveFlags "$1")"
            shift 2
            ;;
        ---dockerfile)
            ViashDockerfile
            exit 0
            ;;
        ---v|---volume)
            VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS -v "$2""
            shift 2
            ;;
        ---volume=*)
            VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS -v $(ViashRemoveFlags "$2")"
            shift 1
            ;;
        ---debug)
            VIASH_MODE='docker_debug'
            shift 1
            ;;
        *)  # positional arg or unknown option
            # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
            VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
            shift # past argument
            ;;
    esac
done

# parse positional parameters
eval set -- $VIASH_POSITIONAL_ARGS


ViashDockerInstallationCheck
if [ $VIASH_MODE == "docker_setup" ]; then
  ViashDockerSetup 'ghcr.io/openpipelines-bio/mapping_bd_rhapsody_wta:main_build' "$VIASH_DOCKER_SETUP_STRATEGY"
  exit 0
fi
ViashDockerSetup 'ghcr.io/openpipelines-bio/mapping_bd_rhapsody_wta:main_build' ifneedbepullelsecachedbuild
if [ $VIASH_MODE == "docker_debug" ]; then
  ViashNotice "+ docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t 'ghcr.io/openpipelines-bio/mapping_bd_rhapsody_wta:main_build'"
  docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t 'ghcr.io/openpipelines-bio/mapping_bd_rhapsody_wta:main_build'
  exit 0
fi




# check whether required parameters exist
if [ -z "$VIASH_PAR_INPUT" ]; then
  ViashError '--input' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z "$VIASH_PAR_REFERENCE_GENOME" ]; then
  ViashError '--reference_genome' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ]; then
  ViashError '--transcriptome_annotation' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z "$VIASH_PAR_OUTPUT" ]; then
  ViashError '--output' is a required argument. Use "--help" to get more information on the parameters.
  exit 1
fi
if [ -z "$VIASH_PAR_DISABLE_PUTATIVE_CALLING" ]; then
  VIASH_PAR_DISABLE_PUTATIVE_CALLING="false"
fi
if [ -z "$VIASH_PAR_PARALLEL" ]; then
  VIASH_PAR_PARALLEL="true"
fi
if [ -z "$VIASH_PAR_TIMESTAMPS" ]; then
  VIASH_PAR_TIMESTAMPS="false"
fi
if [ -z "$VIASH_PAR_DRYRUN" ]; then
  VIASH_PAR_DRYRUN="false"
fi


# check whether parameters values are of the right type






if [[ -n "$VIASH_PAR_EXACT_CELL_COUNT" ]]; then
  if ! [[ "$VIASH_PAR_EXACT_CELL_COUNT" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError '--exact_cell_count' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

if [[ -n "$VIASH_PAR_DISABLE_PUTATIVE_CALLING" ]]; then
  if ! [[ "$VIASH_PAR_DISABLE_PUTATIVE_CALLING" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--disable_putative_calling' has to be a boolean_true. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

if [[ -n "$VIASH_PAR_SUBSAMPLE" ]]; then
  if ! [[ "$VIASH_PAR_SUBSAMPLE" =~ ^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$ ]]; then
    ViashError '--subsample' has to be a double. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

if [[ -n "$VIASH_PAR_SUBSAMPLE_SEED" ]]; then
  if ! [[ "$VIASH_PAR_SUBSAMPLE_SEED" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError '--subsample_seed' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi



if [[ -n "$VIASH_PAR_PARALLEL" ]]; then
  if ! [[ "$VIASH_PAR_PARALLEL" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--parallel' has to be a boolean. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

if [[ -n "$VIASH_PAR_TIMESTAMPS" ]]; then
  if ! [[ "$VIASH_PAR_TIMESTAMPS" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--timestamps' has to be a boolean_true. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

if [[ -n "$VIASH_PAR_OVERRIDE_MIN_RAM" ]]; then
  if ! [[ "$VIASH_PAR_OVERRIDE_MIN_RAM" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError '--override_min_ram' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

if [[ -n "$VIASH_PAR_OVERRIDE_MIN_CORES" ]]; then
  if ! [[ "$VIASH_PAR_OVERRIDE_MIN_CORES" =~ ^[-+]?[0-9]+$ ]]; then
    ViashError '--override_min_cores' has to be an integer. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi

if [[ -n "$VIASH_PAR_DRYRUN" ]]; then
  if ! [[ "$VIASH_PAR_DRYRUN" =~ ^(true|True|TRUE|false|False|FALSE|yes|Yes|YES|no|No|NO)$ ]]; then
    ViashError '--dryrun' has to be a boolean_true. Use "--help" to get more information on the parameters.
    exit 1
  fi
fi


# check whether parameters values are of the right type










if [ ! -z "$VIASH_PAR_SAMPLE_TAGS_VERSION" ]; then
  VIASH_PAR_SAMPLE_TAGS_VERSION_CHOICES=("human:hs:mouse:mm")
  IFS=:
  set -f
  if ! [[ ":${VIASH_PAR_SAMPLE_TAGS_VERSION_CHOICES[*]}:" =~ ":$VIASH_PAR_SAMPLE_TAGS_VERSION:" ]]; then
    ViashError '--sample_tags_version' specified value of \'$VIASH_PAR_SAMPLE_TAGS_VERSION\' is not in the list of allowed values. Use "--help" to get more information on the parameters.
    exit 1
  fi
  set +f
  unset IFS
fi








# detect volumes from file arguments
if [ ! -z "$VIASH_PAR_INPUT" ]; then
  IFS=":"
  for var in $VIASH_PAR_INPUT; do
    unset IFS
    VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$var")"
    if [ -z "$VIASH_TEST_INPUT" ]; then
      VIASH_TEST_INPUT="$(ViashAutodetectMount "$var")"
    else
      VIASH_TEST_INPUT="$VIASH_TEST_INPUT:""$(ViashAutodetectMount "$var")"
    fi
  done
  VIASH_PAR_INPUT="$VIASH_TEST_INPUT"
fi
if [ ! -z "$VIASH_PAR_REFERENCE_GENOME" ]; then
  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_REFERENCE_GENOME")"
  VIASH_PAR_REFERENCE_GENOME=$(ViashAutodetectMount "$VIASH_PAR_REFERENCE_GENOME")
fi
if [ ! -z "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION" ]; then
  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION")"
  VIASH_PAR_TRANSCRIPTOME_ANNOTATION=$(ViashAutodetectMount "$VIASH_PAR_TRANSCRIPTOME_ANNOTATION")
fi
if [ ! -z "$VIASH_PAR_ABSEQ_REFERENCE" ]; then
  IFS=":"
  for var in $VIASH_PAR_ABSEQ_REFERENCE; do
    unset IFS
    VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$var")"
    if [ -z "$VIASH_TEST_ABSEQ_REFERENCE" ]; then
      VIASH_TEST_ABSEQ_REFERENCE="$(ViashAutodetectMount "$var")"
    else
      VIASH_TEST_ABSEQ_REFERENCE="$VIASH_TEST_ABSEQ_REFERENCE:""$(ViashAutodetectMount "$var")"
    fi
  done
  VIASH_PAR_ABSEQ_REFERENCE="$VIASH_TEST_ABSEQ_REFERENCE"
fi
if [ ! -z "$VIASH_PAR_SUPPLEMENTAL_REFERENCE" ]; then
  IFS=":"
  for var in $VIASH_PAR_SUPPLEMENTAL_REFERENCE; do
    unset IFS
    VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$var")"
    if [ -z "$VIASH_TEST_SUPPLEMENTAL_REFERENCE" ]; then
      VIASH_TEST_SUPPLEMENTAL_REFERENCE="$(ViashAutodetectMount "$var")"
    else
      VIASH_TEST_SUPPLEMENTAL_REFERENCE="$VIASH_TEST_SUPPLEMENTAL_REFERENCE:""$(ViashAutodetectMount "$var")"
    fi
  done
  VIASH_PAR_SUPPLEMENTAL_REFERENCE="$VIASH_TEST_SUPPLEMENTAL_REFERENCE"
fi
if [ ! -z "$VIASH_PAR_OUTPUT" ]; then
  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_OUTPUT")"
  VIASH_PAR_OUTPUT=$(ViashAutodetectMount "$VIASH_PAR_OUTPUT")
fi

# Always mount the resource directory
VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_META_RESOURCES_DIR")"
VIASH_META_RESOURCES_DIR=$(ViashAutodetectMount "$VIASH_META_RESOURCES_DIR")
VIASH_META_EXECUTABLE=$(ViashAutodetectMount "$VIASH_META_EXECUTABLE")

# Always mount the VIASH_TEMP directory
VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_TEMP")"
VIASH_TEMP=$(ViashAutodetectMount "$VIASH_TEMP")
# change file ownership
function ViashPerformChown {
  
  if [ ! -z "$VIASH_PAR_OUTPUT" ]; then
    eval docker run --entrypoint=chown -i --rm $VIASH_EXTRA_MOUNTS ghcr.io/openpipelines-bio/mapping_bd_rhapsody_wta:main_build "$(id -u):$(id -g)" --silent --recursive "$VIASH_PAR_OUTPUT"
  fi
}
trap ViashPerformChown EXIT


cat << VIASHEOF | eval docker run --entrypoint=bash -i --rm $VIASH_EXTRA_MOUNTS ghcr.io/openpipelines-bio/mapping_bd_rhapsody_wta:main_build
set -e
tempscript=\$(mktemp "$VIASH_TEMP/viash-run-bd_rhapsody_wta-XXXXXX")
function clean_up {
  rm "\$tempscript"
}
function interrupt {
  echo -e "\nCTRL-C Pressed..."
  exit 1
}
trap clean_up EXIT
trap interrupt INT SIGINT
cat > "\$tempscript" << 'VIASHMAIN'

import os
import re
import subprocess
import tempfile

## VIASH START
# The following code has been auto-generated by Viash.
par = {
  'input': $( if [ ! -z ${VIASH_PAR_INPUT+x} ]; then echo "'${VIASH_PAR_INPUT//\'/\\\'}'.split(':')"; else echo None; fi ),
  'reference_genome': $( if [ ! -z ${VIASH_PAR_REFERENCE_GENOME+x} ]; then echo "'${VIASH_PAR_REFERENCE_GENOME//\'/\\\'}'"; else echo None; fi ),
  'transcriptome_annotation': $( if [ ! -z ${VIASH_PAR_TRANSCRIPTOME_ANNOTATION+x} ]; then echo "'${VIASH_PAR_TRANSCRIPTOME_ANNOTATION//\'/\\\'}'"; else echo None; fi ),
  'abseq_reference': $( if [ ! -z ${VIASH_PAR_ABSEQ_REFERENCE+x} ]; then echo "'${VIASH_PAR_ABSEQ_REFERENCE//\'/\\\'}'.split(':')"; else echo None; fi ),
  'supplemental_reference': $( if [ ! -z ${VIASH_PAR_SUPPLEMENTAL_REFERENCE+x} ]; then echo "'${VIASH_PAR_SUPPLEMENTAL_REFERENCE//\'/\\\'}'.split(':')"; else echo None; fi ),
  'output': $( if [ ! -z ${VIASH_PAR_OUTPUT+x} ]; then echo "'${VIASH_PAR_OUTPUT//\'/\\\'}'"; else echo None; fi ),
  'exact_cell_count': $( if [ ! -z ${VIASH_PAR_EXACT_CELL_COUNT+x} ]; then echo "int('${VIASH_PAR_EXACT_CELL_COUNT//\'/\\\'}')"; else echo None; fi ),
  'disable_putative_calling': $( if [ ! -z ${VIASH_PAR_DISABLE_PUTATIVE_CALLING+x} ]; then echo "'${VIASH_PAR_DISABLE_PUTATIVE_CALLING//\'/\\\'}'.lower() == 'true'"; else echo None; fi ),
  'subsample': $( if [ ! -z ${VIASH_PAR_SUBSAMPLE+x} ]; then echo "float('${VIASH_PAR_SUBSAMPLE//\'/\\\'}')"; else echo None; fi ),
  'subsample_seed': $( if [ ! -z ${VIASH_PAR_SUBSAMPLE_SEED+x} ]; then echo "int('${VIASH_PAR_SUBSAMPLE_SEED//\'/\\\'}')"; else echo None; fi ),
  'sample_tags_version': $( if [ ! -z ${VIASH_PAR_SAMPLE_TAGS_VERSION+x} ]; then echo "'${VIASH_PAR_SAMPLE_TAGS_VERSION//\'/\\\'}'"; else echo None; fi ),
  'tag_names': $( if [ ! -z ${VIASH_PAR_TAG_NAMES+x} ]; then echo "'${VIASH_PAR_TAG_NAMES//\'/\\\'}'.split(':')"; else echo None; fi ),
  'parallel': $( if [ ! -z ${VIASH_PAR_PARALLEL+x} ]; then echo "'${VIASH_PAR_PARALLEL//\'/\\\'}'.lower() == 'true'"; else echo None; fi ),
  'timestamps': $( if [ ! -z ${VIASH_PAR_TIMESTAMPS+x} ]; then echo "'${VIASH_PAR_TIMESTAMPS//\'/\\\'}'.lower() == 'true'"; else echo None; fi ),
  'override_min_ram': $( if [ ! -z ${VIASH_PAR_OVERRIDE_MIN_RAM+x} ]; then echo "int('${VIASH_PAR_OVERRIDE_MIN_RAM//\'/\\\'}')"; else echo None; fi ),
  'override_min_cores': $( if [ ! -z ${VIASH_PAR_OVERRIDE_MIN_CORES+x} ]; then echo "int('${VIASH_PAR_OVERRIDE_MIN_CORES//\'/\\\'}')"; else echo None; fi ),
  'dryrun': $( if [ ! -z ${VIASH_PAR_DRYRUN+x} ]; then echo "'${VIASH_PAR_DRYRUN//\'/\\\'}'.lower() == 'true'"; else echo None; fi )
}
meta = {
  'functionality_name': '$VIASH_META_FUNCTIONALITY_NAME',
  'resources_dir': '$VIASH_META_RESOURCES_DIR',
  'executable': '$VIASH_META_EXECUTABLE',
  'temp_dir': '$VIASH_TEMP'
}

resources_dir = '$VIASH_META_RESOURCES_DIR'

## VIASH END

def strip_margin(text):
  return re.sub('\\n[ \\t]*\\|', '\\n', text)

# if par_input is a directory, look for fastq files
if len(par["input"]) == 1 and os.path.isdir(par["input"][0]):
  par["input"] = [ os.path.join(dp, f) for dp, dn, filenames in os.walk(par["input"]) for f in filenames if re.match(r'.*\\.fastq.gz', f) ]

# use absolute paths
par["input"] = [ os.path.abspath(f) for f in par["input"] ]
par["reference_genome"] = os.path.abspath(par["reference_genome"])
par["transcriptome_annotation"] = os.path.abspath(par["transcriptome_annotation"])
if par["abseq_reference"]:
  par["abseq_reference"] = [ os.path.abspath(f) for f in par["abseq_reference"] ]
if par["supplemental_reference"]:
  par["supplemental_reference"] = [ os.path.abspath(f) for f in par["supplemental_reference"] ]
par["output"] = os.path.abspath(par["output"])

# create output dir if not exists
if not os.path.exists(par["output"]):
  os.makedirs(par["output"])

# Create params file
config_file = os.path.join(par["output"], "config.yml")
endl = "\\n"

content_list = [f"""#!/usr/bin/env cwl-runner

cwl:tool: rhapsody

# This is a YML file used to specify the inputs for a BD Genomics WTA Rhapsody Analysis pipeline run. See the
# BD Genomics Analysis Setup User Guide (Doc ID: 47383) for more details.

## Reads (required) - Path to your read files in the FASTQ.GZ format. You may specify as many R1/R2 read pairs as you want.
Reads:
"""]

for file in par["input"]:
  content_list.append(strip_margin(f"""\\
 - class: File
   location: "{file}"
"""))

content_list.append(strip_margin(f"""\\

## Reference_Genome (required) - Path to STAR index for tar.gz format. See Doc ID: 47383 for instructions to obtain pre-built STAR index file.
Reference_Genome:
   class: File
   location: "{par["reference_genome"]}"

## Transcriptome_Annotation (required) - Path to GTF annotation file
Transcriptome_Annotation:
   class: File
   location: "{par["transcriptome_annotation"]}"
"""))

if par["abseq_reference"]:
  content_list.append(strip_margin(f"""\\

## AbSeq_Reference (optional) - Path to the AbSeq reference file in FASTA format.  Only needed if BD AbSeq Ab-Oligos are used.
## For putative cell calling using an AbSeq dataset, please provide an AbSeq reference fasta file as the AbSeq_Reference.
AbSeq_Reference:
"""))
  for file in par["abseq_reference"]:
    content_list.append(strip_margin(f"""\\
 - class: File
   location: {file}
"""))

if par["supplemental_reference"]:
  content_list.append(strip_margin(f"""\\

## Supplemental_Reference (optional) - Path to the supplemental reference file in FASTA format.  Only needed if there are additional transgene sequences used in the experiment.
Supplemental_Reference:
"""))
  for file in par["supplemental_reference"]:
    content_list.append(strip_margin(f"""\\
 - class: File
   location: {file}
"""))

## Putative Cell Calling Settings
content_list.append(strip_margin(f"""\\

####################################
## Putative Cell Calling Settings ##
####################################
"""))

if par["exact_cell_count"]:
  content_list.append(strip_margin(f"""\\
## Exact cell count (optional) - Set a specific number (>=1) of cells as putative, based on those with the highest error-corrected read count
Exact_Cell_Count: {par["exact_cell_count"]}
"""))

if par["disable_putative_calling"]:
  content_list.append(strip_margin(f"""\\
## Disable Refined Putative Cell Calling (optional) - Determine putative cells using only the basic algorithm (minimum second derivative along the cumulative reads curve).  The refined algorithm attempts to remove false positives and recover false negatives, but may not be ideal for certain complex mixtures of cell types.  Does not apply if Exact Cell Count is set.
## The values can be true or false. By default, the refined algorithm is used.
Basic_Algo_Only: {str(par["disable_putative_calling"]).lower()}
"""))

## Subsample Settings
content_list.append(strip_margin(f"""\\

########################
## Subsample Settings ##
########################
"""
))

if par["subsample"]:
  content_list.append(strip_margin(f"""\\
## Subsample (optional) - A number >1 or fraction (0 < n < 1) to indicate the number or percentage of reads to subsample.
Subsample: {par["subsample"]}
"""))

if par["subsample_seed"]:
  content_list.append(strip_margin(f"""\\
## Subsample seed (optional) - A seed for replicating a previous subsampled run.
Subsample_seed: {par["subsample_seed"]}
"""))


## Multiplex options
content_list.append(strip_margin(f"""\\

#######################
## Multiplex options ##
#######################
"""
))

if par["sample_tags_version"]:
  content_list.append(strip_margin(f"""\\
## Sample Tags Version (optional) - Specify if multiplexed run: human, hs, mouse or mm
Sample_Tags_Version: {par["sample_tags_version"]}
"""))

if par["tag_names"]:
  content_list.append(strip_margin(f"""\\
## Tag_Names (optional) - Specify the tag number followed by '-' and the desired sample name to appear in Sample_Tag_Metrics.csv
# Do not use the special characters: &, (), [], {{}},  <>, ?, |
Tag_Names: [{', '.join(par["tag_names"])}]
"""))

## Write config to file
config_content = ''.join(content_list)

with open(config_file, "w") as f:
  f.write(config_content)

## Process parameters
proc_pars = ["--no-container"]

if par["parallel"]:
  proc_pars.append("--parallel")

if par["timestamps"]:
  proc_pars.append("--timestamps")

# create cwl file (if need be)
orig_cwl_file=os.path.abspath(os.path.join(meta["resources_dir"], "rhapsody_wta_1.9.1_nodocker.cwl"))
if par["override_min_ram"] or par["override_min_cores"]:
  cwl_file = os.path.join(par["output"], "pipeline.cwl")

  # Read in the file
  with open(orig_cwl_file, 'r') as file :
    cwl_data = file.read()

  # Replace the target string
  if par["override_min_ram"]:
    cwl_data = re.sub('"ramMin": [^\\n]*,\\n', f'"ramMin": {par["override_min_ram"] * 1000},\\n', cwl_data)
  if par["override_min_cores"]:
    cwl_data = re.sub('"coresMin": [^\\n]*,\\n', f'"coresMin": {par["override_min_cores"]},\\n', cwl_data)

  # Write the file out again
  with open(cwl_file, 'w') as file:
    file.write(cwl_data)
else:
  cwl_file = orig_cwl_file

## Run pipeline
if not par["dryrun"]:
  with tempfile.TemporaryDirectory(prefix="cwl-bd_rhapsody_wta-", dir=meta["temp_dir"]) as temp_dir:
    cmd = ["cwl-runner"] + proc_pars + [cwl_file, os.path.basename(config_file)]

    env = dict(os.environ)
    env["TMPDIR"] = temp_dir
    env["_JAVA_OPTIONS"] = "-Dpicard.useLegacyParser=true"

    print("> " + ' '.join(cmd))

    p = subprocess.Popen(
      cmd,
      cwd=os.path.dirname(config_file),
      env=env
    )
    p.wait()

    if p.returncode != 0:
      raise Exception(f"cwl-runner finished with exit code {p.returncode}") 

VIASHMAIN
python "\$tempscript" &
wait "\$!"

VIASHEOF
