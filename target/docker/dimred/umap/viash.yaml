functionality:
  name: "umap"
  namespace: "dimred"
  version: "integration_build"
  authors:
  - name: "Dries De Maeyer"
    email: "ddemaeyer@gmail.com"
    roles:
    - "maintainer"
    props:
      account: "ddemaey1"
  inputs: []
  outputs: []
  arguments:
  - type: "file"
    name: "--input"
    alternatives: []
    description: "Input h5mu file"
    example:
    - "input.h5mu"
    default: []
    must_exist: false
    required: true
    direction: "input"
    multiple: false
    multiple_sep: ":"
  - type: "string"
    name: "--modality"
    alternatives: []
    example: []
    default:
    - "rna"
    required: false
    choices: []
    direction: "input"
    multiple: true
    multiple_sep: ":"
  - type: "file"
    name: "--output"
    alternatives:
    - "-o"
    description: "Output h5mu file."
    example:
    - "output.h5mu"
    default: []
    must_exist: false
    required: true
    direction: "output"
    multiple: false
    multiple_sep: ":"
  - type: "string"
    name: "--output_key"
    alternatives: []
    description: "The pre/postfix under which to store the UMAP results."
    example: []
    default:
    - "umap"
    required: false
    choices: []
    direction: "input"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--min_dist"
    alternatives: []
    description: "The effective minimum distance between embedded points. Smaller\
      \ values will result in a more clustered/clumped embedding where nearby points\
      \ on the manifold are drawn closer together, while larger values will result\
      \ on a more even dispersal of points. The value should be set relative to the\
      \ spread value, which determines the scale at which embedded points will be\
      \ spread out."
    example: []
    default:
    - 0.5
    required: false
    direction: "input"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--spread"
    alternatives: []
    description: "The effective scale of embedded points. In combination with min_dist\
      \ this determines how clustered/clumped the embedded points are."
    example: []
    default:
    - 1.0
    required: false
    direction: "input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--num_components"
    alternatives: []
    description: "The number of dimensions of the embedding."
    example: []
    default:
    - 2
    required: false
    choices: []
    direction: "input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--max_iter"
    alternatives: []
    description: "The number of iterations (epochs) of the optimization."
    example: []
    default: []
    required: false
    choices: []
    direction: "input"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--alpha"
    alternatives: []
    description: "The initial learning rate for the embedding optimization."
    example: []
    default:
    - 1.0
    required: false
    direction: "input"
    multiple: false
    multiple_sep: ":"
  - type: "double"
    name: "--gamma"
    alternatives: []
    description: "Weighting applied to negative samples in low dimensional embedding\
      \ optimization. Values higher than one will result in greater weight being given\
      \ to negative samples."
    example: []
    default:
    - 1.0
    required: false
    direction: "input"
    multiple: false
    multiple_sep: ":"
  - type: "integer"
    name: "--negative_sample_rate"
    alternatives: []
    description: "The number of negative edge/1-simplex samples to use per positive\
      \ edge/1-simplex sample in optimizing the low dimensional embedding."
    example: []
    default:
    - 5
    required: false
    choices: []
    direction: "input"
    multiple: false
    multiple_sep: ":"
  - type: "string"
    name: "--init_pos"
    alternatives: []
    description: "How to initialize the low dimensional embedding. Called init in\
      \ the original UMAP. Options are paga, spectral and random."
    example: []
    default:
    - "spectral"
    required: false
    choices: []
    direction: "input"
    multiple: false
    multiple_sep: ":"
  argument_groups: []
  resources:
  - type: "bash_script"
    text: |
      #!/usr/bin/env bash
      
      # umap integration_build
      # 
      # This wrapper script is auto-generated by viash 0.5.15 and is thus a derivative
      # work thereof. This software comes with ABSOLUTELY NO WARRANTY from Data
      # Intuitive.
      # 
      # The component may contain files which fall under a different license. The
      # authors of this component should specify the license in the header of such
      # files, or include a separate license file detailing the licenses of all included
      # files.
      # 
      # Component authors:
      #  * Dries De Maeyer <ddemaeyer@gmail.com> (maintainer) {account: ddemaey1}
      
      set -e
      
      if [ -z "$VIASH_TEMP" ]; then
        VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMPDIR}
        VIASH_TEMP=${VIASH_TEMP:-$VIASH_TEMPDIR}
        VIASH_TEMP=${VIASH_TEMP:-$VIASH_TMP}
        VIASH_TEMP=${VIASH_TEMP:-$TMPDIR}
        VIASH_TEMP=${VIASH_TEMP:-$TMP}
        VIASH_TEMP=${VIASH_TEMP:-$TEMPDIR}
        VIASH_TEMP=${VIASH_TEMP:-$TEMP}
        VIASH_TEMP=${VIASH_TEMP:-/tmp}
      fi
      
      # define helper functions
      # ViashQuote: put quotes around non flag values
      # $1     : unquoted string
      # return : possibly quoted string
      # examples:
      #   ViashQuote --foo      # returns --foo
      #   ViashQuote bar        # returns 'bar'
      #   Viashquote --foo=bar  # returns --foo='bar'
      function ViashQuote {
        if [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+=.+$ ]]; then
          echo "$1" | sed "s#=\(.*\)#='\1'#"
        elif [[ "$1" =~ ^-+[a-zA-Z0-9_\-]+$ ]]; then
          echo "$1"
        else
          echo "'$1'"
        fi
      }
      # ViashRemoveFlags: Remove leading flag
      # $1     : string with a possible leading flag
      # return : string without possible leading flag
      # examples:
      #   ViashRemoveFlags --foo=bar  # returns bar
      function ViashRemoveFlags {
        echo "$1" | sed 's/^--*[a-zA-Z0-9_\-]*=//'
      }
      # ViashSourceDir: return the path of a bash file, following symlinks
      # usage   : ViashSourceDir ${BASH_SOURCE[0]}
      # $1      : Should always be set to ${BASH_SOURCE[0]}
      # returns : The absolute path of the bash file
      function ViashSourceDir {
        SOURCE="$1"
        while [ -h "$SOURCE" ]; do
          DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
          SOURCE="$(readlink "$SOURCE")"
          [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
        done
        cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd
      }
      # see https://en.wikipedia.org/wiki/Syslog#Severity_level
      VIASH_LOGCODE_EMERGENCY=0
      VIASH_LOGCODE_ALERT=1
      VIASH_LOGCODE_CRITICAL=2
      VIASH_LOGCODE_ERROR=3
      VIASH_LOGCODE_WARNING=4
      VIASH_LOGCODE_NOTICE=5
      VIASH_LOGCODE_INFO=6
      VIASH_LOGCODE_DEBUG=7
      VIASH_VERBOSITY=$VIASH_LOGCODE_NOTICE
      
      # ViashLog: Log events depending on the verbosity level
      # usage: ViashLog 1 alert Oh no something went wrong!
      # $1: required verbosity level
      # $2: display tag
      # $3+: messages to display
      # stdout: Your input, prepended by '[$2] '.
      function ViashLog {
        local required_level="$1"
        local display_tag="$2"
        shift 2
        if [ $VIASH_VERBOSITY -ge $required_level ]; then
          echo "[$display_tag]" "$@"
        fi
      }
      
      # ViashEmergency: log events when the system is unstable
      # usage: ViashEmergency Oh no something went wrong.
      # stdout: Your input, prepended by '[emergency] '.
      function ViashEmergency {
        ViashLog $VIASH_LOGCODE_EMERGENCY emergency $@
      }
      
      # ViashAlert: log events when actions must be taken immediately (e.g. corrupted system database)
      # usage: ViashAlert Oh no something went wrong.
      # stdout: Your input, prepended by '[alert] '.
      function ViashAlert {
        ViashLog $VIASH_LOGCODE_ALERT alert $@
      }
      
      # ViashCritical: log events when a critical condition occurs
      # usage: ViashCritical Oh no something went wrong.
      # stdout: Your input, prepended by '[critical] '.
      function ViashCritical {
        ViashLog $VIASH_LOGCODE_CRITICAL critical $@
      }
      
      # ViashError: log events when an error condition occurs
      # usage: ViashError Oh no something went wrong.
      # stdout: Your input, prepended by '[error] '.
      function ViashError {
        ViashLog $VIASH_LOGCODE_ERROR error $@
      }
      
      # ViashWarning: log potentially abnormal events
      # usage: ViashWarning Something may have gone wrong.
      # stdout: Your input, prepended by '[warning] '.
      function ViashWarning {
        ViashLog $VIASH_LOGCODE_WARNING warning $@
      }
      
      # ViashNotice: log significant but normal events
      # usage: ViashNotice This just happened.
      # stdout: Your input, prepended by '[notice] '.
      function ViashNotice {
        ViashLog $VIASH_LOGCODE_NOTICE notice $@
      }
      
      # ViashInfo: log normal events
      # usage: ViashInfo This just happened.
      # stdout: Your input, prepended by '[info] '.
      function ViashInfo {
        ViashLog $VIASH_LOGCODE_INFO info $@
      }
      
      # ViashDebug: log all events, for debugging purposes
      # usage: ViashDebug This just happened.
      # stdout: Your input, prepended by '[debug] '.
      function ViashDebug {
        ViashLog $VIASH_LOGCODE_DEBUG debug $@
      }
      
      # find source folder of this component
      VIASH_META_RESOURCES_DIR=`ViashSourceDir ${BASH_SOURCE[0]}`
      
      # backwards compatibility
      VIASH_RESOURCES_DIR="$VIASH_META_RESOURCES_DIR"
      
      # define meta fields
      VIASH_META_FUNCTIONALITY_NAME="umap"
      VIASH_META_EXECUTABLE="$VIASH_META_RESOURCES_DIR/$VIASH_META_FUNCTIONALITY_NAME"
      
      
      # ViashHelp: Display helpful explanation about this executable
      function ViashHelp {
        echo "umap integration_build"
        echo ""
        echo "UMAP (Uniform Manifold Approximation and Projection) is a manifold learning"
        echo "technique suitable for visualizing high-dimensional data. Besides tending to be"
        echo "faster than tSNE, it optimizes the embedding such that it best reflects the"
        echo "topology of the data, which we represent throughout Scanpy using a neighborhood"
        echo "graph. tSNE, by contrast, optimizes the distribution of nearest-neighbor"
        echo "distances in the embedding such that these best match the distribution of"
        echo "distances in the high-dimensional space. We use the implementation of umap-learn"
        echo "[McInnes18]. For a few comparisons of UMAP with tSNE, see this preprint."
        echo ""
        echo "Arguments:"
        echo "    --input"
        echo "        type: file, required parameter"
        echo "        example: input.h5mu"
        echo "        Input h5mu file"
        echo ""
        echo "    --modality"
        echo "        type: string, multiple values allowed"
        echo "        default: rna"
        echo ""
        echo "    -o, --output"
        echo "        type: file, required parameter, output"
        echo "        example: output.h5mu"
        echo "        Output h5mu file."
        echo ""
        echo "    --output_key"
        echo "        type: string"
        echo "        default: umap"
        echo "        The pre/postfix under which to store the UMAP results."
        echo ""
        echo "    --min_dist"
        echo "        type: double"
        echo "        default: 0.5"
        echo "        The effective minimum distance between embedded points. Smaller values"
        echo "        will result in a more clustered/clumped embedding where nearby points on"
        echo "        the manifold are drawn closer together, while larger values will result"
        echo "        on a more even dispersal of points. The value should be set relative to"
        echo "        the spread value, which determines the scale at which embedded points"
        echo "        will be spread out."
        echo ""
        echo "    --spread"
        echo "        type: double"
        echo "        default: 1.0"
        echo "        The effective scale of embedded points. In combination with min_dist"
        echo "        this determines how clustered/clumped the embedded points are."
        echo ""
        echo "    --num_components"
        echo "        type: integer"
        echo "        default: 2"
        echo "        The number of dimensions of the embedding."
        echo ""
        echo "    --max_iter"
        echo "        type: integer"
        echo "        The number of iterations (epochs) of the optimization."
        echo ""
        echo "    --alpha"
        echo "        type: double"
        echo "        default: 1.0"
        echo "        The initial learning rate for the embedding optimization."
        echo ""
        echo "    --gamma"
        echo "        type: double"
        echo "        default: 1.0"
        echo "        Weighting applied to negative samples in low dimensional embedding"
        echo "        optimization. Values higher than one will result in greater weight being"
        echo "        given to negative samples."
        echo ""
        echo "    --negative_sample_rate"
        echo "        type: integer"
        echo "        default: 5"
        echo "        The number of negative edge/1-simplex samples to use per positive"
        echo "        edge/1-simplex sample in optimizing the low dimensional embedding."
        echo ""
        echo "    --init_pos"
        echo "        type: string"
        echo "        default: spectral"
        echo "        How to initialize the low dimensional embedding. Called init in the"
        echo "        original UMAP. Options are paga, spectral and random."
      }
      ######## Helper functions for setting up Docker images for viash ########
      # expects: ViashDockerBuild
      
      # ViashDockerInstallationCheck: check whether Docker is installed correctly
      #
      # examples:
      #   ViashDockerInstallationCheck
      function ViashDockerInstallationCheck {
        ViashDebug "Checking whether Docker is installed"
        if [ ! command -v docker &> /dev/null ]; then
          ViashCritical "Docker doesn't seem to be installed. See 'https://docs.docker.com/get-docker/' for instructions."
          exit 1
        fi
      
        ViashDebug "Checking whether the Docker daemon is running"
        save=$-; set +e
        docker_version=$(docker version --format '{{.Client.APIVersion}}' 2> /dev/null)
        out=$?
        [[ $save =~ e ]] && set -e
        if [ $out -ne 0 ]; then
          ViashCritical "Docker daemon does not seem to be running. Try one of the following:"
          ViashCritical "- Try running 'dockerd' in the command line"
          ViashCritical "- See https://docs.docker.com/config/daemon/"
          exit 1
        fi
      }
      
      # ViashDockerRemoteTagCheck: check whether a Docker image is available 
      # on a remote. Assumes `docker login` has been performed, if relevant.
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # exit code $?        : whether or not the image was found
      # examples:
      #   ViashDockerRemoteTagCheck python:latest
      #   echo $?                                     # returns '0'
      #   ViashDockerRemoteTagCheck sdaizudceahifu
      #   echo $?                                     # returns '1'
      function ViashDockerRemoteTagCheck {
        docker manifest inspect $1 > /dev/null 2> /dev/null
      }
      
      # ViashDockerLocalTagCheck: check whether a Docker image is available locally
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # exit code $?        : whether or not the image was found
      # examples:
      #   docker pull python:latest
      #   ViashDockerLocalTagCheck python:latest
      #   echo $?                                     # returns '0'
      #   ViashDockerLocalTagCheck sdaizudceahifu
      #   echo $?                                     # returns '1'
      function ViashDockerLocalTagCheck {
        [ -n "$(docker images -q $1)" ]
      }
      
      # ViashDockerPull: pull a Docker image
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # exit code $?        : whether or not the image was found
      # examples:
      #   ViashDockerPull python:latest
      #   echo $?                                     # returns '0'
      #   ViashDockerPull sdaizudceahifu
      #   echo $?                                     # returns '1'
      function ViashDockerPull {
        ViashNotice "Checking if Docker image is available at '$1'"
        if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
          docker pull $1 && return 0 || return 1
        else
          save=$-; set +e
          docker pull $1 2> /dev/null > /dev/null
          out=$?
          [[ $save =~ e ]] && set -e
          if [ $out -ne 0 ]; then
            ViashWarning "Could not pull from '$1'. Docker image doesn't exist or is not accessible."
          fi
          return $out
        fi
      }
      
      # ViashDockerPush: push a Docker image
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # exit code $?        : whether or not the image was found
      # examples:
      #   ViashDockerPush python:latest
      #   echo $?                                     # returns '0'
      #   ViashDockerPush sdaizudceahifu
      #   echo $?                                     # returns '1'
      function ViashDockerPush {
        ViashNotice "Pushing image to '$1'"
        save=$-; set +e
        if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
          docker push $1
          out=$?
        else
          docker push $1 2> /dev/null > /dev/null
          out=$?
        fi
        [[ $save =~ e ]] && set -e
        if [ $out -eq 0 ]; then
          ViashNotice "Container '$VSHD_ID' push succeeded."
        else
          ViashError "Container '$VSHD_ID' push errored. You might not be logged in or have the necessary permissions."
        fi
        return $out
      }
      
      # ViashDockerPullElseBuild: pull a Docker image, else build it
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
      # examples:
      #   ViashDockerPullElseBuild mynewcomponent
      function ViashDockerPullElseBuild {
        save=$-; set +e
        ViashDockerPull $1
        out=$?
        [[ $save =~ e ]] && set -e
        if [ $out -ne 0 ]; then
          ViashDockerBuild $@
        fi
      }
      
      # ViashDockerSetup: create a Docker image, according to specified docker setup strategy
      #
      # $1                  : image identifier with format `[registry/]image[:tag]`
      # $2                  : docker setup strategy, see DockerSetupStrategy.scala
      # ViashDockerBuild    : a Bash function which builds a docker image, takes image identifier as argument.
      # examples:
      #   ViashDockerSetup mynewcomponent alwaysbuild
      function ViashDockerSetup {
        VSHD_ID="$1"
        VSHD_STRAT="$2"
        if [ "$VSHD_STRAT" == "alwaysbuild" -o "$VSHD_STRAT" == "build" -o "$VSHD_STRAT" == "b" ]; then
          ViashDockerBuild $VSHD_ID --no-cache
        elif [ "$VSHD_STRAT" == "alwayspull" -o "$VSHD_STRAT" == "pull" -o "$VSHD_STRAT" == "p" ]; then
          ViashDockerPull $VSHD_ID
        elif [ "$VSHD_STRAT" == "alwayspullelsebuild" -o "$VSHD_STRAT" == "pullelsebuild" ]; then
          ViashDockerPullElseBuild $VSHD_ID --no-cache
        elif [ "$VSHD_STRAT" == "alwayspullelsecachedbuild" -o "$VSHD_STRAT" == "pullelsecachedbuild" ]; then
          ViashDockerPullElseBuild $VSHD_ID
        elif [ "$VSHD_STRAT" == "alwayscachedbuild" -o "$VSHD_STRAT" == "cachedbuild" -o "$VSHD_STRAT" == "cb" ]; then
          ViashDockerBuild $VSHD_ID
        elif [[ "$VSHD_STRAT" =~ ^ifneedbe ]]; then
          save=$-; set +e
          ViashDockerLocalTagCheck $VSHD_ID
          outCheck=$?
          [[ $save =~ e ]] && set -e
          if [ $outCheck -eq 0 ]; then
            ViashInfo "Image $VSHD_ID already exists"
          elif [ "$VSHD_STRAT" == "ifneedbebuild" ]; then
            ViashDockerBuild $VSHD_ID --no-cache
          elif [ "$VSHD_STRAT" == "ifneedbecachedbuild" ]; then
            ViashDockerBuild $VSHD_ID
          elif [ "$VSHD_STRAT" == "ifneedbepull" ]; then
            ViashDockerPull $VSHD_ID
          elif [ "$VSHD_STRAT" == "ifneedbepullelsebuild" ]; then
            ViashDockerPullElseBuild $VSHD_ID --no-cache
          elif [ "$VSHD_STRAT" == "ifneedbepullelsecachedbuild" ]; then
            ViashDockerPullElseBuild $VSHD_ID
          else
            ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
            exit 1
          fi
        elif [ "$VSHD_STRAT" == "push" -o "$VSHD_STRAT" == "forcepush" -o "$VSHD_STRAT" == "alwayspush" ]; then
          ViashDockerPush "$VSHD_ID"
        elif [ "$VSHD_STRAT" == "pushifnotpresent" -o "$VSHD_STRAT" == "gentlepush" -o "$VSHD_STRAT" == "maybepush" ]; then
          save=$-; set +e
          ViashDockerRemoteTagCheck $VSHD_ID
          outCheck=$?
          [[ $save =~ e ]] && set -e
          if [ $outCheck -eq 0 ]; then
            ViashNotice "Container '$VSHD_ID' exists, doing nothing."
          else
            ViashNotice "Container '$VSHD_ID' does not yet exist."
            ViashDockerPush "$VSHD_ID"
          fi
        elif [ "$VSHD_STRAT" == "donothing" -o "$VSHD_STRAT" == "meh" ]; then
          ViashNotice "Skipping setup."
        else
          ViashError "Unrecognised Docker strategy: $VSHD_STRAT"
          exit 1
        fi
      }
      
      
      ######## End of helper functions for setting up Docker images for viash ########
      
      # ViashDockerFile: print the dockerfile to stdout
      # return : dockerfile required to run this component
      # examples:
      #   ViashDockerFile
      function ViashDockerfile {
        cat << 'VIASHDOCKER'
      FROM python:3.8-slim
      
      RUN pip install --upgrade pip && \
        pip install --upgrade --no-cache-dir "scanpy~=1.9.1" "muon" "mudata~=0.2.0" "anndata~=0.8.0"
      
      LABEL org.opencontainers.image.authors="Dries De Maeyer <ddemaeyer@gmail.com> (maintainer) {account: ddemaey1}"
      LABEL org.opencontainers.image.description="Companion container for running component dimred umap"
      LABEL org.opencontainers.image.created="2022-08-08T07:43:36Z"
      LABEL org.opencontainers.image.source="https://github.com/openpipelines-bio/openpipeline"
      LABEL org.opencontainers.image.revision="d9fabfede74d9ffb49a1cf92402d508c43106ab0"
      LABEL org.opencontainers.image.version="integration_build"
      VIASHDOCKER
      }
      
      # ViashDockerBuild: build a docker container
      # $1              : image identifier with format `[registry/]image[:tag]`
      # exit code $?    : whether or not the image was built
      function ViashDockerBuild {
        # create temporary directory to store dockerfile & optional resources in
        tmpdir=$(mktemp -d "$VIASH_TEMP/viashsetupdocker-umap-XXXXXX")
        function clean_up {
          rm -rf "$tmpdir"
        }
        trap clean_up EXIT
      
        # store dockerfile and resources
        ViashDockerfile > $tmpdir/Dockerfile
        cp -r $VIASH_META_RESOURCES_DIR/* $tmpdir
      
        # Build the container
        ViashNotice "Building container '$1' with Dockerfile"
        ViashInfo "Running 'docker build -t $@ $tmpdir'"
        save=$-; set +e
        if [ $VIASH_VERBOSITY -ge $VIASH_LOGCODE_INFO ]; then
          docker build -t $@ $tmpdir
        else
          docker build -t $@ $tmpdir &> $tmpdir/docker_build.log
        fi
        out=$?
        [[ $save =~ e ]] && set -e
        if [ $out -ne 0 ]; then
          ViashError "Error occurred while building container '$1'"
          if [ $VIASH_VERBOSITY -lt $VIASH_LOGCODE_INFO ]; then
            ViashError "Transcript: --------------------------------"
            cat "$tmpdir/docker_build.log"
            ViashError "End of transcript --------------------------"
          fi
          exit 1
        fi
      }
      # ViashAbsolutePath: generate absolute path from relative path
      # borrowed from https://stackoverflow.com/a/21951256
      # $1     : relative filename
      # return : absolute path
      # examples:
      #   ViashAbsolutePath some_file.txt   # returns /path/to/some_file.txt
      #   ViashAbsolutePath /foo/bar/..     # returns /foo
      function ViashAbsolutePath {
        local thePath
        if [[ ! "$1" =~ ^/ ]]; then
          thePath="$PWD/$1"
        else
          thePath="$1"
        fi
        echo "$thePath" | (
          IFS=/
          read -a parr
          declare -a outp
          for i in "${parr[@]}"; do
            case "$i" in
            ''|.) continue ;;
            ..)
              len=${#outp[@]}
              if ((len==0)); then
                continue
              else
                unset outp[$((len-1))]
              fi
              ;;
            *)
              len=${#outp[@]}
              outp[$len]="$i"
            ;;
            esac
          done
          echo /"${outp[*]}"
        )
      }
      # ViashAutodetectMount: auto configuring docker mounts from parameters
      # $1                  : The parameter value
      # returns             : New parameter
      # $VIASH_EXTRA_MOUNTS : Added another parameter to be passed to docker
      # examples:
      #   ViashAutodetectMount /path/to/bar      # returns '/viash_automount/path/to/bar'
      #   ViashAutodetectMountArg /path/to/bar   # returns '-v /path/to:/viash_automount/path/to'
      function ViashAutodetectMount {
        abs_path=$(ViashAbsolutePath "$1")
        if [ -d "$abs_path" ]; then
          mount_source="$abs_path"
          base_name=""
        else
          mount_source=`dirname "$abs_path"`
          base_name=`basename "$abs_path"`
        fi
        mount_target="/viash_automount$mount_source"
        echo "$mount_target/$base_name"
      }
      function ViashAutodetectMountArg {
        abs_path=$(ViashAbsolutePath "$1")
        if [ -d "$abs_path" ]; then
          mount_source="$abs_path"
          base_name=""
        else
          mount_source=`dirname "$abs_path"`
          base_name=`basename "$abs_path"`
        fi
        mount_target="/viash_automount$mount_source"
        echo "-v \"$mount_source:$mount_target\""
      }
      # ViashExtractFlags: Retain leading flag
      # $1     : string with a possible leading flag
      # return : leading flag
      # examples:
      #   ViashExtractFlags --foo=bar  # returns --foo
      function ViashExtractFlags {
        echo $1 | sed 's/=.*//'
      }
      # initialise variables
      VIASH_EXTRA_MOUNTS=''
      
      # initialise array
      VIASH_POSITIONAL_ARGS=''
      VIASH_MODE='run'
      
      while [[ $# -gt 0 ]]; do
          case "$1" in
              -h|--help)
                  ViashHelp
                  exit
                  ;;
              ---v|---verbose)
                  let "VIASH_VERBOSITY=VIASH_VERBOSITY+1"
                  shift 1
                  ;;
              ---verbosity)
                  VIASH_VERBOSITY="$2"
                  shift 2
                  ;;
              ---verbosity=*)
                  VIASH_VERBOSITY="$(ViashRemoveFlags "$1")"
                  shift 1
                  ;;
              --version)
                  echo "umap integration_build"
                  exit
                  ;;
              --input)
                  VIASH_PAR_INPUT="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --input. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --input=*)
                  VIASH_PAR_INPUT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --modality)
                  if [ -z "$VIASH_PAR_MODALITY" ]; then
                    VIASH_PAR_MODALITY="$2"
                  else
                    VIASH_PAR_MODALITY="$VIASH_PAR_MODALITY:""$2"
                  fi
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --modality. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --modality=*)
                  if [ -z "$VIASH_PAR_MODALITY" ]; then
                    VIASH_PAR_MODALITY=$(ViashRemoveFlags "$1")
                  else
                    VIASH_PAR_MODALITY="$VIASH_PAR_MODALITY:"$(ViashRemoveFlags "$1")
                  fi
                  shift 1
                  ;;
              --output)
                  VIASH_PAR_OUTPUT="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --output. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --output=*)
                  VIASH_PAR_OUTPUT=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              -o)
                  VIASH_PAR_OUTPUT="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to -o. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --output_key)
                  VIASH_PAR_OUTPUT_KEY="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --output_key. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --output_key=*)
                  VIASH_PAR_OUTPUT_KEY=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --min_dist)
                  VIASH_PAR_MIN_DIST="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --min_dist. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --min_dist=*)
                  VIASH_PAR_MIN_DIST=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --spread)
                  VIASH_PAR_SPREAD="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --spread. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --spread=*)
                  VIASH_PAR_SPREAD=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --num_components)
                  VIASH_PAR_NUM_COMPONENTS="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --num_components. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --num_components=*)
                  VIASH_PAR_NUM_COMPONENTS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --max_iter)
                  VIASH_PAR_MAX_ITER="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --max_iter. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --max_iter=*)
                  VIASH_PAR_MAX_ITER=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --alpha)
                  VIASH_PAR_ALPHA="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --alpha. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --alpha=*)
                  VIASH_PAR_ALPHA=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --gamma)
                  VIASH_PAR_GAMMA="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --gamma. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --gamma=*)
                  VIASH_PAR_GAMMA=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --negative_sample_rate)
                  VIASH_PAR_NEGATIVE_SAMPLE_RATE="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --negative_sample_rate. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --negative_sample_rate=*)
                  VIASH_PAR_NEGATIVE_SAMPLE_RATE=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              --init_pos)
                  VIASH_PAR_INIT_POS="$2"
                  [ $# -lt 2 ] && ViashError Not enough arguments passed to --init_pos. Use "--help" to get more information on the parameters. && exit 1
                  shift 2
                  ;;
              --init_pos=*)
                  VIASH_PAR_INIT_POS=$(ViashRemoveFlags "$1")
                  shift 1
                  ;;
              ---setup)
                  VIASH_MODE='docker_setup'
                  VIASH_DOCKER_SETUP_STRATEGY="$2"
                  shift 1
                  ;;
              ---setup=*)
                  VIASH_MODE='docker_setup'
                  VIASH_DOCKER_SETUP_STRATEGY="$(ViashRemoveFlags "$1")"
                  shift 2
                  ;;
              ---dockerfile)
                  ViashDockerfile
                  exit 0
                  ;;
              ---v|---volume)
                  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS -v "$2""
                  shift 2
                  ;;
              ---volume=*)
                  VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS -v $(ViashRemoveFlags "$2")"
                  shift 1
                  ;;
              ---debug)
                  VIASH_MODE='docker_debug'
                  shift 1
                  ;;
              *)  # positional arg or unknown option
                  # since the positional args will be eval'd, can we always quote, instead of using ViashQuote
                  VIASH_POSITIONAL_ARGS="$VIASH_POSITIONAL_ARGS '$1'"
                  shift # past argument
                  ;;
          esac
      done
      
      # parse positional parameters
      eval set -- $VIASH_POSITIONAL_ARGS
      
      
      ViashDockerInstallationCheck
      if [ $VIASH_MODE == "docker_setup" ]; then
        ViashDockerSetup 'ghcr.io/openpipelines-bio/dimred_umap:integration_build' "$VIASH_DOCKER_SETUP_STRATEGY"
        exit 0
      fi
      ViashDockerSetup 'ghcr.io/openpipelines-bio/dimred_umap:integration_build' ifneedbepullelsecachedbuild
      if [ $VIASH_MODE == "docker_debug" ]; then
        ViashNotice "+ docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t 'ghcr.io/openpipelines-bio/dimred_umap:integration_build'"
        docker run --entrypoint=bash -i --rm -v "$(pwd)":/pwd --workdir /pwd -t 'ghcr.io/openpipelines-bio/dimred_umap:integration_build'
        exit 0
      fi
      
      
      
      
      # check whether required parameters exist
      if [ -z "$VIASH_PAR_INPUT" ]; then
        ViashError '--input' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_OUTPUT" ]; then
        ViashError '--output' is a required argument. Use "--help" to get more information on the parameters.
        exit 1
      fi
      if [ -z "$VIASH_PAR_MODALITY" ]; then
        VIASH_PAR_MODALITY="rna"
      fi
      if [ -z "$VIASH_PAR_OUTPUT_KEY" ]; then
        VIASH_PAR_OUTPUT_KEY="umap"
      fi
      if [ -z "$VIASH_PAR_MIN_DIST" ]; then
        VIASH_PAR_MIN_DIST="0.5"
      fi
      if [ -z "$VIASH_PAR_SPREAD" ]; then
        VIASH_PAR_SPREAD="1.0"
      fi
      if [ -z "$VIASH_PAR_NUM_COMPONENTS" ]; then
        VIASH_PAR_NUM_COMPONENTS="2"
      fi
      if [ -z "$VIASH_PAR_ALPHA" ]; then
        VIASH_PAR_ALPHA="1.0"
      fi
      if [ -z "$VIASH_PAR_GAMMA" ]; then
        VIASH_PAR_GAMMA="1.0"
      fi
      if [ -z "$VIASH_PAR_NEGATIVE_SAMPLE_RATE" ]; then
        VIASH_PAR_NEGATIVE_SAMPLE_RATE="5"
      fi
      if [ -z "$VIASH_PAR_INIT_POS" ]; then
        VIASH_PAR_INIT_POS="spectral"
      fi
      
      
      # check whether parameters values are of the right type
      
      
      
      
      if [[ -n "$VIASH_PAR_MIN_DIST" ]]; then
        if ! [[ "$VIASH_PAR_MIN_DIST" =~ ^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$ ]]; then
          ViashError '--min_dist' has to be a double. Use "--help" to get more information on the parameters.
          exit 1
        fi
      fi
      
      if [[ -n "$VIASH_PAR_SPREAD" ]]; then
        if ! [[ "$VIASH_PAR_SPREAD" =~ ^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$ ]]; then
          ViashError '--spread' has to be a double. Use "--help" to get more information on the parameters.
          exit 1
        fi
      fi
      
      if [[ -n "$VIASH_PAR_NUM_COMPONENTS" ]]; then
        if ! [[ "$VIASH_PAR_NUM_COMPONENTS" =~ ^[-+]?[0-9]+$ ]]; then
          ViashError '--num_components' has to be an integer. Use "--help" to get more information on the parameters.
          exit 1
        fi
      fi
      
      if [[ -n "$VIASH_PAR_MAX_ITER" ]]; then
        if ! [[ "$VIASH_PAR_MAX_ITER" =~ ^[-+]?[0-9]+$ ]]; then
          ViashError '--max_iter' has to be an integer. Use "--help" to get more information on the parameters.
          exit 1
        fi
      fi
      
      if [[ -n "$VIASH_PAR_ALPHA" ]]; then
        if ! [[ "$VIASH_PAR_ALPHA" =~ ^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$ ]]; then
          ViashError '--alpha' has to be a double. Use "--help" to get more information on the parameters.
          exit 1
        fi
      fi
      
      if [[ -n "$VIASH_PAR_GAMMA" ]]; then
        if ! [[ "$VIASH_PAR_GAMMA" =~ ^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$ ]]; then
          ViashError '--gamma' has to be a double. Use "--help" to get more information on the parameters.
          exit 1
        fi
      fi
      
      if [[ -n "$VIASH_PAR_NEGATIVE_SAMPLE_RATE" ]]; then
        if ! [[ "$VIASH_PAR_NEGATIVE_SAMPLE_RATE" =~ ^[-+]?[0-9]+$ ]]; then
          ViashError '--negative_sample_rate' has to be an integer. Use "--help" to get more information on the parameters.
          exit 1
        fi
      fi
      
      
      
      # check whether parameters values are of the right type
      
      
      
      
      
      
      
      
      
      
      
      
      
      # detect volumes from file arguments
      if [ ! -z "$VIASH_PAR_INPUT" ]; then
        VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_INPUT")"
        VIASH_PAR_INPUT=$(ViashAutodetectMount "$VIASH_PAR_INPUT")
      fi
      if [ ! -z "$VIASH_PAR_OUTPUT" ]; then
        VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_PAR_OUTPUT")"
        VIASH_PAR_OUTPUT=$(ViashAutodetectMount "$VIASH_PAR_OUTPUT")
      fi
      
      # Always mount the resource directory
      VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_META_RESOURCES_DIR")"
      VIASH_META_RESOURCES_DIR=$(ViashAutodetectMount "$VIASH_META_RESOURCES_DIR")
      VIASH_META_EXECUTABLE=$(ViashAutodetectMount "$VIASH_META_EXECUTABLE")
      
      # Always mount the VIASH_TEMP directory
      VIASH_EXTRA_MOUNTS="$VIASH_EXTRA_MOUNTS $(ViashAutodetectMountArg "$VIASH_TEMP")"
      VIASH_TEMP=$(ViashAutodetectMount "$VIASH_TEMP")
      # change file ownership
      function ViashPerformChown {
        
        if [ ! -z "$VIASH_PAR_OUTPUT" ]; then
          eval docker run --entrypoint=chown -i --rm $VIASH_EXTRA_MOUNTS ghcr.io/openpipelines-bio/dimred_umap:integration_build "$(id -u):$(id -g)" --silent --recursive "$VIASH_PAR_OUTPUT"
        fi
      }
      trap ViashPerformChown EXIT
      
      
      cat << VIASHEOF | eval docker run --entrypoint=bash -i --rm $VIASH_EXTRA_MOUNTS ghcr.io/openpipelines-bio/dimred_umap:integration_build
      set -e
      tempscript=\$(mktemp "$VIASH_TEMP/viash-run-umap-XXXXXX")
      function clean_up {
        rm "\$tempscript"
      }
      function interrupt {
        echo -e "\nCTRL-C Pressed..."
        exit 1
      }
      trap clean_up EXIT
      trap interrupt INT SIGINT
      cat > "\$tempscript" << 'VIASHMAIN'
      
      import scanpy as sc
      import muon as mu
      
      ## VIASH START
      # The following code has been auto-generated by Viash.
      par = {
        'input': $( if [ ! -z ${VIASH_PAR_INPUT+x} ]; then echo "'${VIASH_PAR_INPUT//\'/\\\'}'"; else echo None; fi ),
        'modality': $( if [ ! -z ${VIASH_PAR_MODALITY+x} ]; then echo "'${VIASH_PAR_MODALITY//\'/\\\'}'.split(':')"; else echo None; fi ),
        'output': $( if [ ! -z ${VIASH_PAR_OUTPUT+x} ]; then echo "'${VIASH_PAR_OUTPUT//\'/\\\'}'"; else echo None; fi ),
        'output_key': $( if [ ! -z ${VIASH_PAR_OUTPUT_KEY+x} ]; then echo "'${VIASH_PAR_OUTPUT_KEY//\'/\\\'}'"; else echo None; fi ),
        'min_dist': $( if [ ! -z ${VIASH_PAR_MIN_DIST+x} ]; then echo "float('${VIASH_PAR_MIN_DIST//\'/\\\'}')"; else echo None; fi ),
        'spread': $( if [ ! -z ${VIASH_PAR_SPREAD+x} ]; then echo "float('${VIASH_PAR_SPREAD//\'/\\\'}')"; else echo None; fi ),
        'num_components': $( if [ ! -z ${VIASH_PAR_NUM_COMPONENTS+x} ]; then echo "int('${VIASH_PAR_NUM_COMPONENTS//\'/\\\'}')"; else echo None; fi ),
        'max_iter': $( if [ ! -z ${VIASH_PAR_MAX_ITER+x} ]; then echo "int('${VIASH_PAR_MAX_ITER//\'/\\\'}')"; else echo None; fi ),
        'alpha': $( if [ ! -z ${VIASH_PAR_ALPHA+x} ]; then echo "float('${VIASH_PAR_ALPHA//\'/\\\'}')"; else echo None; fi ),
        'gamma': $( if [ ! -z ${VIASH_PAR_GAMMA+x} ]; then echo "float('${VIASH_PAR_GAMMA//\'/\\\'}')"; else echo None; fi ),
        'negative_sample_rate': $( if [ ! -z ${VIASH_PAR_NEGATIVE_SAMPLE_RATE+x} ]; then echo "int('${VIASH_PAR_NEGATIVE_SAMPLE_RATE//\'/\\\'}')"; else echo None; fi ),
        'init_pos': $( if [ ! -z ${VIASH_PAR_INIT_POS+x} ]; then echo "'${VIASH_PAR_INIT_POS//\'/\\\'}'"; else echo None; fi )
      }
      meta = {
        'functionality_name': '$VIASH_META_FUNCTIONALITY_NAME',
        'resources_dir': '$VIASH_META_RESOURCES_DIR',
        'executable': '$VIASH_META_EXECUTABLE',
        'temp_dir': '$VIASH_TEMP'
      }
      
      resources_dir = '$VIASH_META_RESOURCES_DIR'
      
      ## VIASH END
      
      print("Reading", par["input"])
      mdata = mu.read_h5mu(par["input"])
      
      for mod in par['modality']:
          print(f"Computing UMAP for modality '{mod}'")
          data = mdata.mod[mod]
      
          sc.tl.umap(
              data,
              min_dist=par["min_dist"],
              spread=par["spread"],
              n_components=par["num_components"],
              maxiter=par["max_iter"],
              alpha=par["alpha"],
              gamma=par["gamma"],
              negative_sample_rate=par["negative_sample_rate"],
              init_pos=par["init_pos"],
          )
          # note: should be able to set the neighbors key
      
      print("Writing", par["output"])
      mdata.write_h5mu(filename=par["output"])
      
      VIASHMAIN
      python "\$tempscript" &
      wait "\$!"
      
      VIASHEOF
      

    dest: "umap"
    is_executable: true
  description: "UMAP (Uniform Manifold Approximation and Projection) is a manifold\
    \ learning technique suitable for visualizing high-dimensional data. Besides tending\
    \ to be faster than tSNE, it optimizes the embedding such that it best reflects\
    \ the topology of the data, which we represent throughout Scanpy using a neighborhood\
    \ graph. tSNE, by contrast, optimizes the distribution of nearest-neighbor distances\
    \ in the embedding such that these best match the distribution of distances in\
    \ the high-dimensional space. We use the implementation of umap-learn [McInnes18].\
    \ For a few comparisons of UMAP with tSNE, see this preprint.\n"
  test_resources:
  - type: "python_script"
    path: "run_test.py"
    is_executable: true
  - type: "file"
    path: "../../../resources_test/pbmc_1k_protein_v3"
  info: {}
  dummy_arguments: []
  set_wd_to_resources_dir: false
  enabled: true
platform:
  type: "docker"
  id: "docker"
  image: "python:3.8-slim"
  target_organization: "openpipelines-bio"
  target_registry: "ghcr.io"
  namespace_separator: "_"
  resolve_volume: "Automatic"
  chown: true
  port: []
  setup_strategy: "ifneedbepullelsecachedbuild"
  privileged: false
  run_args: []
  target_image_source: "https://github.com/openpipelines-bio/openpipeline"
  setup: []
  python:
    user: false
    packages:
    - "scanpy~=1.9.1"
    - "muon"
    - "mudata~=0.2.0"
    - "anndata~=0.8.0"
    pip: []
    pypi: []
    git: []
    github: []
    gitlab: []
    mercurial: []
    svn: []
    bazaar: []
    url: []
    script: []
    upgrade: true
    type: "python"
  test_setup: []
platforms: []
info:
  config: "src/dimred/umap/config.vsh.yaml"
  platform: "docker"
  output: "target/docker/dimred/umap"
  executable: "target/docker/dimred/umap/umap"
  viash_version: "0.5.15"
  git_commit: "d9fabfede74d9ffb49a1cf92402d508c43106ab0"
  git_remote: "https://github.com/openpipelines-bio/openpipeline"
